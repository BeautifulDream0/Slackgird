{
  "version": 3,
  "file": "angular-slickgrid.umd.min.js",
  "sources": [
    "ng://angular-slickgrid/node_modules/tslib/tslib.es6.js",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/services/utilities.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/services/export.service.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/models/delimiterType.enum.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/models/fileType.enum.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/models/operatorType.enum.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/filter-conditions/booleanFilterCondition.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/filter-conditions/filterUtilities.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/filter-conditions/dateFilterCondition.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/filter-conditions/dateIsoFilterCondition.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/filter-conditions/dateUsFilterCondition.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/filter-conditions/dateUsShortFilterCondition.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/filter-conditions/dateUtcFilterCondition.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/filter-conditions/collectionSearchFilterCondition.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/filter-conditions/numberFilterCondition.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/filter-conditions/stringFilterCondition.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/filter-conditions/executeMappedCondition.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/filter-conditions/index.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/filters/inputFilter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/filters/multipleSelectFilter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/filters/selectFilter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/filters/singleSelectFilter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/filters/index.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/services/controlAndPlugin.service.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/services/filter.service.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/services/graphqlQueryBuilder.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/services/graphql.service.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/services/odata.service.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/services/global-utilities.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/services/grid-odata.service.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/services/gridExtra.service.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/services/gridEvent.service.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/sorters/dateUsShortSorter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/services/gridExtraUtils.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/services/gridState.service.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/services/resizer.service.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/sorters/dateSorter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/sorters/dateIsoSorter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/sorters/dateUsSorter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/sorters/numericSorter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/sorters/stringSorter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/sorters/index.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/services/sort.service.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/editors/dateEditor.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/editors/checkboxEditor.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/editors/integerEditor.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/editors/floatEditor.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/editors/longTextEditor.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/editors/textEditor.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/editors/index.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/formatters/arrayToCsvFormatter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/formatters/checkmarkFormatter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/formatters/lowercaseFormatter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/formatters/complexObjectFormatter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/formatters/dateTimeIsoAmPmFormatter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/formatters/dateTimeUsAmPmFormatter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/formatters/dateUsFormatter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/formatters/editIconFormatter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/formatters/hyperlinkFormatter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/formatters/multipleFormatter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/formatters/percentCompleteFormatter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/formatters/percentCompleteBarFormatter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/formatters/progressBarFormatter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/formatters/translateFormatter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/formatters/translateBooleanFormatter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/formatters/uppercaseFormatter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/formatters/yesNoFormatter.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/formatters/index.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/components/slick-pagination.component.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/global-grid-options.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/services/shared.service.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/components/angular-slickgrid.component.ts",
    "ng://angular-slickgrid/out/src/app/modules/angular-slickgrid/modules/angular-slickgrid.module.ts"
  ],
  "sourcesContent": [
    "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n",
    "import { FieldType, OperatorType, FilterType, FormElementType } from '../models/index';\r\nimport { Observable } from 'rxjs/Observable';\r\nimport 'rxjs/add/operator/first';\r\nimport 'rxjs/add/operator/take';\r\nimport 'rxjs/add/operator/toPromise';\r\nimport * as moment_ from 'moment-mini';\r\nconst moment = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\n\r\n/** Simple function to which will loop and create as demanded the number of white spaces,\r\n * this will be used in the Excel export\r\n * @param int nbSpaces: number of white spaces to create\r\n */\r\nexport function addWhiteSpaces(nbSpaces): string {\r\n  let result = '';\r\n\r\n  for (let i = 0; i < nbSpaces; i++) {\r\n    result += ' ';\r\n  }\r\n  return result;\r\n}\r\n\r\n/** decode text into html entity\r\n * @param string text: input text\r\n * @param string text: output text\r\n */\r\nexport function htmlEntityDecode(input: string): string {\r\n  return input.replace(/&#(\\d+);/g, function (match, dec) {\r\n    return String.fromCharCode(dec);\r\n  });\r\n}\r\n\r\n/** decode text into html entity\r\n * @param string text: input text\r\n * @param string text: output text\r\n */\r\nexport function htmlEntityEncode(input: any): string {\r\n  const buf = [];\r\n  for (let i = input.length - 1; i >= 0; i--) {\r\n    buf.unshift(['&#', input[i].charCodeAt(), ';'].join(''));\r\n  }\r\n  return buf.join('');\r\n}\r\n\r\n/**\r\n * Try casting an input of type Promise | Observable into a Promise type.\r\n * @param object which could be of type Promise or Observable\r\n * @param fromServiceName string representing the caller service name and will be used if we throw a casting problem error\r\n */\r\nexport function castToPromise<T>(input: Promise<T> | Observable<T>, fromServiceName: string = ''): Promise<T> {\r\n  let promise: any = input;\r\n\r\n  if (input instanceof Promise) {\r\n    // if it's already a Promise then return it\r\n    return input;\r\n  } else if (input instanceof Observable) {\r\n    promise = input.first().toPromise();\r\n    if (!(promise instanceof Promise)) {\r\n      promise = input.take(1).toPromise();\r\n    }\r\n    if (!(promise instanceof Promise)) {\r\n      throw new Error(\r\n        `Something went wrong, Angular-Slickgrid ${fromServiceName} is not able to convert the Observable into a Promise.\r\n        If you are using Angular HttpClient, you could try converting your http call to a Promise with \".toPromise()\"\r\n        for example::  this.http.post('graphql', { query: graphqlQuery }).toPromise()\r\n        `);\r\n    }\r\n  }\r\n\r\n  return promise;\r\n}\r\n\r\n/**\r\n * From a Date FieldType, return it's equivalent moment.js format\r\n * refer to moment.js for the format standard used: https://momentjs.com/docs/#/parsing/string-format/\r\n * @param fieldType\r\n */\r\nexport function mapMomentDateFormatWithFieldType(fieldType: FieldType): string {\r\n  let map: string;\r\n  switch (fieldType) {\r\n    case FieldType.dateTime:\r\n    case FieldType.dateTimeIso:\r\n      map = 'YYYY-MM-DD HH:mm:ss';\r\n      break;\r\n    case FieldType.dateTimeIsoAmPm:\r\n      map = 'YYYY-MM-DD hh:mm:ss a';\r\n      break;\r\n    case FieldType.dateTimeIsoAM_PM:\r\n      map = 'YYYY-MM-DD hh:mm:ss A';\r\n      break;\r\n    case FieldType.dateUs:\r\n      map = 'MM/DD/YYYY';\r\n      break;\r\n    case FieldType.dateUsShort:\r\n      map = 'M/D/YY';\r\n      break;\r\n    case FieldType.dateTimeUs:\r\n      map = 'MM/DD/YYYY HH:mm:ss';\r\n      break;\r\n    case FieldType.dateTimeUsAmPm:\r\n      map = 'MM/DD/YYYY hh:mm:ss a';\r\n      break;\r\n    case FieldType.dateTimeUsAM_PM:\r\n      map = 'MM/DD/YYYY hh:mm:ss A';\r\n      break;\r\n    case FieldType.dateTimeUsShort:\r\n      map = 'M/D/YY H:m:s';\r\n      break;\r\n    case FieldType.dateTimeUsShortAmPm:\r\n      map = 'M/D/YY h:m:s a';\r\n      break;\r\n    case FieldType.dateUtc:\r\n      map = 'YYYY-MM-DDTHH:mm:ss.SSSZ';\r\n      break;\r\n    case FieldType.date:\r\n    case FieldType.dateIso:\r\n    default:\r\n      map = 'YYYY-MM-DD';\r\n      break;\r\n  }\r\n  return map;\r\n}\r\n\r\n/**\r\n * From a Date FieldType, return it's equivalent Flatpickr format\r\n * refer to Flatpickr for the format standard used: https://chmln.github.io/flatpickr/formatting/#date-formatting-tokens\r\n * also note that they seem very similar to PHP format (except for am/pm): http://php.net/manual/en/function.date.php\r\n * @param fieldType\r\n */\r\nexport function mapFlatpickrDateFormatWithFieldType(fieldType: FieldType): string {\r\n  /*\r\n    d: Day of the month, 2 digits with leading zeros\t01 to 31\r\n    D: A textual representation of a day\tMon through Sun\r\n    l: (lowercase 'L')\tA full textual representation of the day of the week\tSunday through Saturday\r\n    j: Day of the month without leading zeros\t1 to 31\r\n    J: Day of the month without leading zeros and ordinal suffix\t1st, 2nd, to 31st\r\n    w: Numeric representation of the day of the week\t0 (for Sunday) through 6 (for Saturday)\r\n    F: A full textual representation of a month\tJanuary through December\r\n    m: Numeric representation of a month, with leading zero\t01 through 12\r\n    n: Numeric representation of a month, without leading zeros\t1 through 12\r\n    M: A short textual representation of a month\tJan through Dec\r\n    U: The number of seconds since the Unix Epoch\t1413704993\r\n    y: A two digit representation of a year\t99 or 03\r\n    Y: A full numeric representation of a year, 4 digits\t1999 or 2003\r\n    H: Hours (24 hours)\t00 to 23\r\n    h: Hours\t1 to 12\r\n    i: Minutes\t00 to 59\r\n    S: Seconds, 2 digits\t00 to 59\r\n    s: Seconds\t0, 1 to 59\r\n    K: AM/PM\tAM or PM\r\n  */\r\n  let map: string;\r\n  switch (fieldType) {\r\n    case FieldType.dateTime:\r\n    case FieldType.dateTimeIso:\r\n      map = 'Y-m-d H:i:S';\r\n      break;\r\n    case FieldType.dateTimeIsoAmPm:\r\n      map = 'Y-m-d h:i:S K'; // there is no lowercase in Flatpickr :(\r\n      break;\r\n    case FieldType.dateTimeIsoAM_PM:\r\n      map = 'Y-m-d h:i:S K';\r\n      break;\r\n    case FieldType.dateUs:\r\n      map = 'm/d/Y';\r\n      break;\r\n    case FieldType.dateUsShort:\r\n      map = 'M/D/YY';\r\n      break;\r\n    case FieldType.dateTimeUs:\r\n      map = 'm/d/Y H:i:S';\r\n      break;\r\n    case FieldType.dateTimeUsAmPm:\r\n      map = 'm/d/Y h:i:S K'; // there is no lowercase in Flatpickr :(\r\n      break;\r\n    case FieldType.dateTimeUsAM_PM:\r\n      map = 'M/D/YY h:i:s K';\r\n      break;\r\n    case FieldType.dateTimeUsShort:\r\n      map = 'M/D/YY H:i:s';\r\n      break;\r\n    case FieldType.dateTimeUsShortAmPm:\r\n      map = 'M/D/YY h:i:s K'; // there is no lowercase in Flatpickr :(\r\n      break;\r\n    case FieldType.dateUtc:\r\n      map = 'Z';\r\n      break;\r\n    case FieldType.date:\r\n    case FieldType.dateIso:\r\n    default:\r\n      map = 'Y-m-d';\r\n      break;\r\n  }\r\n  return map;\r\n}\r\n\r\n/**\r\n * Mapper for query operators (ex.: <= is \"le\", > is \"gt\")\r\n * @param string operator\r\n * @returns string map\r\n */\r\nexport function mapOperatorType(operator: string): OperatorType {\r\n  let map: OperatorType;\r\n\r\n  switch (operator) {\r\n    case '<':\r\n      map = OperatorType.lessThan;\r\n      break;\r\n    case '<=':\r\n      map = OperatorType.lessThanOrEqual;\r\n      break;\r\n    case '>':\r\n      map = OperatorType.greaterThan;\r\n      break;\r\n    case '>=':\r\n      map = OperatorType.greaterThanOrEqual;\r\n      break;\r\n    case '<>':\r\n    case '!=':\r\n    case 'neq':\r\n    case 'NEQ':\r\n      map = OperatorType.notEqual;\r\n      break;\r\n    case '*':\r\n    case '.*':\r\n    case 'startsWith':\r\n      map = OperatorType.startsWith;\r\n      break;\r\n    case '*.':\r\n    case 'endsWith':\r\n      map = OperatorType.endsWith;\r\n      break;\r\n    case '=':\r\n    case '==':\r\n    case 'eq':\r\n    case 'EQ':\r\n      map = OperatorType.equal;\r\n      break;\r\n    case 'in':\r\n    case 'IN':\r\n      map = OperatorType.in;\r\n      break;\r\n    case 'notIn':\r\n    case 'NIN':\r\n    case 'NOT_IN':\r\n      map = OperatorType.notIn;\r\n      break;\r\n    default:\r\n      map = OperatorType.contains;\r\n      break;\r\n  }\r\n\r\n  return map;\r\n}\r\n\r\n/**\r\n * Mapper for query operator by a Filter Type\r\n * For example a multiple-select typically uses 'IN' operator\r\n * @param operator\r\n * @returns string map\r\n */\r\nexport function mapOperatorByFilterType(filterType: FilterType | FormElementType | string): OperatorType {\r\n  let map: OperatorType;\r\n\r\n  switch (filterType) {\r\n    case FilterType.multipleSelect:\r\n      map = OperatorType.in;\r\n      break;\r\n    case FilterType.singleSelect:\r\n      map = OperatorType.equal;\r\n      break;\r\n    default:\r\n      map = OperatorType.contains;\r\n      break;\r\n  }\r\n\r\n  return map;\r\n}\r\n\r\n/**\r\n * Parse a date passed as a string and return a Date object (if valid)\r\n * @param inputDateString\r\n * @returns string date formatted\r\n */\r\nexport function parseUtcDate(inputDateString: string, useUtc: boolean): string | null {\r\n  let date = null;\r\n\r\n  if (/^[0-9\\-\\/]*$/.test(inputDateString)) {\r\n    // get the UTC datetime with moment.js but we need to decode the value so that it's valid text\r\n    const dateString = decodeURIComponent(inputDateString);\r\n    const dateMoment = moment(new Date(dateString));\r\n    if (dateMoment.isValid() && dateMoment.year().toString().length === 4) {\r\n      date = (useUtc) ? dateMoment.utc().format() : dateMoment.format();\r\n    }\r\n  }\r\n\r\n  return date;\r\n}\r\n\r\n/**\r\n * Converts a string to camel case\r\n * @param str the string to convert\r\n * @return the string in camel case\r\n */\r\nexport function toCamelCase(str: string): string {\r\n  return str.replace(/(?:^\\w|[A-Z]|\\b\\w|[\\s+\\-_\\/])/g, (match: string, offset: number) => {\r\n    // remove white space or hypens or underscores\r\n    if (/[\\s+\\-_\\/]/.test(match)) {\r\n      return '';\r\n    }\r\n\r\n    return offset === 0 ? match.toLowerCase() : match.toUpperCase();\r\n  });\r\n}\r\n\r\n/**\r\n * Converts a string to kebab (hypen) case\r\n * @param str the string to convert\r\n * @return the string in kebab case\r\n */\r\nexport function toKebabCase(str: string): string {\r\n  return toCamelCase(str).replace(/([A-Z])/g, '-$1').toLowerCase();\r\n}\r\n",
    "import { Injectable } from '@angular/core';\r\nimport {\r\n  CellArgs,\r\n  CustomGridMenu,\r\n  Column,\r\n  DelimiterType,\r\n  ExportOption,\r\n  FileType,\r\n  Formatter,\r\n  GraphqlResult,\r\n  GridMenu,\r\n  GridOption,\r\n  HeaderButtonOnCommandArgs,\r\n  HeaderMenuOnCommandArgs,\r\n  HeaderMenuOnBeforeMenuShowArgs\r\n} from './../models/index';\r\nimport $ from 'jquery';\r\nimport { TranslateService } from '@ngx-translate/core';\r\nimport { addWhiteSpaces, htmlEntityDecode } from './../services/utilities';\r\nimport { TextEncoder } from 'text-encoding-utf-8';\r\n\r\n// using external non-typed js libraries\r\ndeclare let Slick: any;\r\ndeclare let $: any;\r\n\r\nexport interface ExportColumnHeader {\r\n  key: string;\r\n  title: string;\r\n}\r\n\r\n@Injectable()\r\nexport class ExportService {\r\n  private _lineCarriageReturn = '\\n';\r\n  private _dataView: any;\r\n  private _grid: any;\r\n  private _exportQuoteWrapper: string;\r\n  private _existingSlickAggregators: string[] = [];\r\n  private _columnHeaders: ExportColumnHeader[];\r\n  private _groupedHeaders: ExportColumnHeader[];\r\n  private _gridOptions: GridOption;\r\n  private _groupingDefinition: any;\r\n  private _hasGroupedItems = false;\r\n  private _exportOptions: ExportOption;\r\n  defaultExportOptions: ExportOption = {\r\n    delimiter: DelimiterType.comma,\r\n    filename: 'export',\r\n    format: FileType.csv,\r\n    useUtf8WithBom: true\r\n  };\r\n\r\n  constructor(private translate: TranslateService) { }\r\n\r\n  /**\r\n   * Initialize the Export Service\r\n   * @param grid\r\n   * @param gridOptions\r\n   * @param dataView\r\n   */\r\n  init(grid: any, gridOptions: GridOption, dataView: any): void {\r\n    this._grid = grid;\r\n    this._gridOptions = gridOptions;\r\n    this._dataView = dataView;\r\n  }\r\n\r\n  /**\r\n   * Function to export the Grid result to an Excel CSV format using javascript for it to produce the CSV file.\r\n   * This is a WYSIWYG export to file output (What You See is What You Get)\r\n   *\r\n   * NOTES: The column position needs to match perfectly the JSON Object position because of the way we are pulling the data,\r\n   * which means that if any column(s) got moved in the UI, it has to be reflected in the JSON array output as well\r\n   *\r\n   * Example: exportToFile({ format: FileType.csv, delimiter: DelimiterType.comma })\r\n   */\r\n  exportToFile(options: ExportOption) {\r\n    this._exportOptions = $.extend(true, {}, this.defaultExportOptions, options);\r\n\r\n    // get the CSV output from the grid data\r\n    const dataOutput = this.getDataOutput();\r\n\r\n    // trigger a download file\r\n    this.startDownloadFile({\r\n      filename: `${this._exportOptions.filename}.${this._exportOptions.format}`,\r\n      csvContent: dataOutput,\r\n      format: this._exportOptions.format,\r\n      useUtf8WithBom: this._exportOptions.useUtf8WithBom\r\n    });\r\n  }\r\n\r\n  // -----------------------\r\n  // Private functions\r\n  // -----------------------\r\n\r\n  getDataOutput(): string {\r\n    const columns = this._grid.getColumns() || [];\r\n    const delimiter = this._exportOptions.delimiter || '';\r\n    const format = this._exportOptions.format || '';\r\n\r\n    // find all the Aggregators that exist inside SlickGrid\r\n    this._existingSlickAggregators = this.getAllSlickGridAggregators() || [];\r\n\r\n    // a CSV needs double quotes wrapper, the other types do not need any wrapper\r\n    this._exportQuoteWrapper = (format === FileType.csv) ? '\"' : '';\r\n\r\n    // data variable which will hold all the fields data of a row\r\n    let outputDataString = '';\r\n\r\n    // get grouped column titles and if found, we will add a \"Group by\" column at the first column index\r\n    this._groupedHeaders = this.getGroupedColumnTitles(columns) || [];\r\n    if (this._groupedHeaders && Array.isArray(this._groupedHeaders)) {\r\n      this._hasGroupedItems = (this._groupedHeaders.length > 0);\r\n      outputDataString += this._groupedHeaders\r\n        .map((header) => `${this.translate.instant('GROUP_BY')} [${header.title}]`)\r\n        .join(delimiter);\r\n    }\r\n\r\n    // get all column headers\r\n    this._columnHeaders = this.getColumnHeaders(columns) || [];\r\n    if (this._columnHeaders && Array.isArray(this._columnHeaders)) {\r\n      // add the header row + add a new line at the end of the row\r\n      const outputHeaderTitles = this._columnHeaders\r\n        .map((header) => this._exportQuoteWrapper + header.title + this._exportQuoteWrapper);\r\n      outputDataString += (outputHeaderTitles.join(delimiter) + this._lineCarriageReturn);\r\n    }\r\n\r\n    // Populate the rest of the Grid Data\r\n    outputDataString += this.getAllGridRowData(columns, this._lineCarriageReturn);\r\n\r\n    return outputDataString;\r\n  }\r\n\r\n  /**\r\n   * Get all the grid row data and return that as an output string\r\n   */\r\n  getAllGridRowData(columns: Column[], lineCarriageReturn: string): string {\r\n    let outputDataString = '';\r\n    const lineCount = this._dataView.getLength();\r\n\r\n    // loop through all the grid rows of data\r\n    for (let rowNumber = 0; rowNumber < lineCount; rowNumber++) {\r\n      const itemObj = this._dataView.getItem(rowNumber);\r\n\r\n      if (itemObj != null) {\r\n        // Normal row (not grouped by anything) would have an ID which was predefined in the Grid Columns definition\r\n        if (itemObj.id != null) {\r\n          // get regular row item data\r\n          outputDataString += this.readRegularRowData(columns, rowNumber, itemObj);\r\n        } else if (this._hasGroupedItems && itemObj.__groupTotals === undefined) {\r\n          // get the group row\r\n          outputDataString += this.readGroupedTitleRow(itemObj);\r\n        } else if (itemObj.__groupTotals) {\r\n          // else if the row is a Group By and we have agreggators, then a property of '__groupTotals' would exist under that object\r\n          outputDataString += this.readGroupedTotalRow(itemObj);\r\n        }\r\n        outputDataString += lineCarriageReturn;\r\n      }\r\n    }\r\n\r\n    return outputDataString;\r\n  }\r\n\r\n  /**\r\n   * Get all the Slick Aggregators that are defined in SlickGrid\r\n   */\r\n  getAllSlickGridAggregators(): string[] {\r\n    let slickAggregatorCount = 0;\r\n    const existingSlickAggregators = [];\r\n\r\n    for (const key in Slick.Data.Aggregators) {\r\n      if (Slick.Data.Aggregators.hasOwnProperty(key)) {\r\n        slickAggregatorCount++;\r\n        existingSlickAggregators.push(key.toLowerCase());\r\n      }\r\n    }\r\n\r\n    return existingSlickAggregators;\r\n  }\r\n\r\n  /**\r\n   * Get all header titles and their keys, translate the title when required.\r\n   * @param columns of the grid\r\n   */\r\n  getColumnHeaders(columns: Column[]): ExportColumnHeader[] {\r\n    if (!columns || !Array.isArray(columns) || columns.length === 0) {\r\n      return null;\r\n    }\r\n    const columnHeaders = [];\r\n\r\n    // Populate the Column Header, pull the name defined\r\n    columns.forEach((columnDef) => {\r\n      const fieldName = (columnDef.headerKey) ? this.translate.instant(columnDef.headerKey) : columnDef.name;\r\n      const skippedField = columnDef.excludeFromExport || false;\r\n\r\n      // if column width is 0 then it's not evaluated since that field is considered hidden should not be part of the export\r\n      if ((columnDef.width ===  undefined || columnDef.width > 0) && !skippedField) {\r\n        columnHeaders.push({\r\n          key: columnDef.field || columnDef.id,\r\n          title: fieldName\r\n        });\r\n      }\r\n    });\r\n\r\n    return columnHeaders;\r\n  }\r\n\r\n  /**\r\n   * Get the data of a regular row (a row without grouping)\r\n   * @param row\r\n   * @param itemObj\r\n   */\r\n  readRegularRowData(columns: Column[], row: number, itemObj: any) {\r\n    let idx = 0;\r\n    let rowOutputString = '';\r\n    const delimiter = this._exportOptions.delimiter;\r\n    const format = this._exportOptions.format;\r\n    const exportQuoteWrapper = this._exportQuoteWrapper || '';\r\n\r\n    for (let col = 0, ln = columns.length; col < ln; col++) {\r\n      const columnDef = columns[col];\r\n      const fieldId = columnDef.field || columnDef.id || '';\r\n\r\n      // skip excluded column\r\n      if (columnDef.excludeFromExport) {\r\n          continue;\r\n      }\r\n\r\n      // if we are grouping and are on 1st column index, we need to skip this column since it will be used later by the grouping text:: Group by [columnX]\r\n      if (this._hasGroupedItems && idx === 0) {\r\n        rowOutputString += `\"\"` + delimiter;\r\n      }\r\n\r\n      // does the user want to evaluate current column Formatter?\r\n      const isEvaluatingFormatter = (columnDef.exportWithFormatter !== undefined) ? columnDef.exportWithFormatter : this._gridOptions.exportWithFormatter;\r\n\r\n      // did the user provide a Custom Formatter for the export\r\n      const exportCustomFormatter: Formatter = (columnDef.exportCustomFormatter !== undefined) ? columnDef.exportCustomFormatter : undefined;\r\n\r\n      let itemData = '';\r\n\r\n      if (exportCustomFormatter) {\r\n        itemData = exportCustomFormatter(row, col, itemObj[fieldId], columnDef, itemObj, this._grid);\r\n      } else if (isEvaluatingFormatter && !!columnDef.formatter) {\r\n        itemData = columnDef.formatter(row, col, itemObj[fieldId], columnDef, itemObj, this._grid);\r\n      } else {\r\n        itemData = (itemObj[fieldId] === null || itemObj[fieldId] === undefined) ? '' : itemObj[fieldId];\r\n      }\r\n\r\n      // when CSV we also need to escape double quotes twice, so \" becomes \"\"\r\n      if (format === FileType.csv) {\r\n        itemData = itemData.toString().replace(/\"/gi, `\"\"`);\r\n      }\r\n\r\n      // do we have a wrapper to keep as a string? in certain cases like \"1E06\", we don't want excel to transform it into exponential (1.0E06)\r\n      // to cancel that effect we can had = in front, ex: =\"1E06\"\r\n      const keepAsStringWrapper = (columnDef && columnDef.exportCsvForceToKeepAsString) ? '=' : '';\r\n\r\n      rowOutputString += keepAsStringWrapper + exportQuoteWrapper + itemData + exportQuoteWrapper + delimiter;\r\n      idx++;\r\n    }\r\n\r\n    return rowOutputString;\r\n  }\r\n\r\n  /**\r\n   * Get the grouped title(s), for example if we grouped by salesRep, the returned result would be:: 'Sales Rep'\r\n   * @param itemObj\r\n   */\r\n  readGroupedTitleRow(itemObj: any) {\r\n    let groupName = itemObj.value;\r\n    const exportQuoteWrapper = this._exportQuoteWrapper || '';\r\n    const delimiter = this._exportOptions.delimiter;\r\n    const format = this._exportOptions.format;\r\n\r\n    groupName = addWhiteSpaces(5 * itemObj.level) + groupName;\r\n\r\n    if (format === FileType.csv) {\r\n      // when CSV we also need to escape double quotes twice, so \" becomes \"\"\r\n      groupName = groupName.toString().replace(/\"/gi, `\"\"`);\r\n    }\r\n\r\n    // do we have a wrapper to keep as a string? in certain cases like \"1E06\", we don't want excel to transform it into exponential (1.0E06)\r\n    // to cancel that effect we can had = in front, ex: =\"1E06\"\r\n    // const keepAsStringWrapper = (columnDef && columnDef.exportCsvForceToKeepAsString) ? '=' : '';\r\n\r\n    return /*keepAsStringWrapper +*/ exportQuoteWrapper + ' ' + groupName + exportQuoteWrapper + delimiter;\r\n  }\r\n\r\n  /**\r\n   * Get the grouped totals, these are set by Slick Aggregators.\r\n   * For example if we grouped by \"salesRep\" and we have a Sum Aggregator on \"sales\", then the returned output would be:: [\"Sum 123$\"]\r\n   * @param itemObj\r\n   */\r\n  readGroupedTotalRow(itemObj: any) {\r\n    let exportExponentialWrapper = '';\r\n    const delimiter = this._exportOptions.delimiter;\r\n    const format = this._exportOptions.format;\r\n    const exportQuoteWrapper = this._exportQuoteWrapper || '';\r\n    const existingSlickAggregators = this._existingSlickAggregators || [];\r\n    const columnCount = this._grid.getColumns().length;\r\n    let output = `${exportQuoteWrapper}..${exportQuoteWrapper}${delimiter}`;\r\n\r\n    for (let j = 0; j < columnCount; j++) {\r\n      const fieldId = this._grid.getColumns()[j].id;\r\n      let itemData = '';\r\n\r\n      // cycle through all possible SlickGrid Aggregators and get their values\r\n      for (let k = 0; k < existingSlickAggregators.length; k++) {\r\n        if (itemObj[existingSlickAggregators[k]] !== undefined) {\r\n          if (fieldId in itemObj[existingSlickAggregators[k]]) {\r\n            const aggregatorName = existingSlickAggregators[k];\r\n            const val = itemObj[existingSlickAggregators[k]][fieldId];\r\n            if (aggregatorName.toLowerCase() === 'avg') {\r\n              itemData = aggregatorName + ': ' + Math.round(val);\r\n            } else if (aggregatorName.toLowerCase() === 'min' || aggregatorName.toLowerCase() === 'max' || aggregatorName.toLowerCase() === 'sum') {\r\n              itemData = aggregatorName + ': ' + Math.round(parseFloat(val) * 1000000) / 1000000;\r\n            } else {\r\n              itemData = val;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      if (format === FileType.csv) {\r\n        // when CSV we also need to escape double quotes twice, so a double quote \" becomes 2x double quotes \"\"\r\n        // and if we have a text of (number)E(number),\r\n        // we don't want excel to transform it into exponential (1.0E06) to cancel that effect we can had = in front, ex: =\"1E06\"\r\n        itemData = itemData.toString().replace(/\"/gi, `\"\"`);\r\n        exportExponentialWrapper = (itemData.match(/^\\s*\\d+E\\d+\\s*$/i)) ? '=' : '';\r\n      }\r\n      output += exportQuoteWrapper + itemData + exportQuoteWrapper + delimiter;\r\n    }\r\n\r\n    return output;\r\n  }\r\n\r\n  /**\r\n   * Get all grouped column titles, translate them when required.\r\n   * For example if the grid is grouped by salesRep and then customerName, we will return their title, something like:: ['Sales Rep', 'Customer Name']\r\n   * @param columns of the grid\r\n   */\r\n  getGroupedColumnTitles(columns: Column[]): ExportColumnHeader[] {\r\n    if (!columns || !Array.isArray(columns) || columns.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    let groupItemId = '';\r\n    const groupedHeaders = [];\r\n\r\n    let hasGroupedItems = false;\r\n    if ($.isEmptyObject(this._groupingDefinition)) {\r\n      hasGroupedItems = false;\r\n    } else {\r\n      hasGroupedItems = true;\r\n      groupItemId = $(`#${this._groupingDefinition.dropdownOptionsIds[0]}`).val();\r\n    }\r\n\r\n    // If we are Grouping, then pull the name of the grouped item and display it as 1st column\r\n    columns.forEach((columnDef) => {\r\n      // the column might be a complex object and have a '.' (ex.: person.name)\r\n      // if so we want just the object (ex.: person.name => we want 'person')\r\n      if (groupItemId.indexOf('.') >= 0) {\r\n        groupItemId = groupItemId.split('.')[0];\r\n      }\r\n\r\n      if (hasGroupedItems && columnDef.id === groupItemId) {\r\n        const fieldName = (columnDef.headerKey) ? this.translate.instant(columnDef.headerKey) : columnDef.name;\r\n        groupedHeaders.push({\r\n          key: columnDef.field || columnDef.id,\r\n          title: fieldName\r\n        });\r\n      }\r\n    });\r\n\r\n    return groupedHeaders;\r\n  }\r\n\r\n  /**\r\n   * Triggers download file with file format.\r\n   * IE(6-10) are not supported\r\n   * All other browsers will use plain javascript on client side to produce a file download.\r\n   * @param options\r\n   */\r\n  startDownloadFile(options: { filename: string, csvContent: any, format: FileType | string, useUtf8WithBom: boolean }): void {\r\n    // IE(6-10) don't support javascript download and our service doesn't support either so throw an error, we have to make a round trip to the Web Server for exporting\r\n    if (navigator.appName === 'Microsoft Internet Explorer') {\r\n      throw new Error('Microsoft Internet Explorer 6 to 10 do not support javascript export to CSV. Please upgrade your browser.');\r\n    }\r\n\r\n    // set the correct MIME type\r\n    const mimeType = (options.format === FileType.csv) ? 'text/csv' : 'text/plain';\r\n\r\n    // make sure no html entities exist in the data\r\n    const csvContent = htmlEntityDecode(options.csvContent);\r\n\r\n    // dealing with Excel CSV export and UTF-8 is a little tricky.. We will use Option #2 to cover older Excel versions\r\n    // Option #1: we need to make Excel knowing that it's dealing with an UTF-8, A correctly formatted UTF8 file can have a Byte Order Mark as its first three octets\r\n    // reference: http://stackoverflow.com/questions/155097/microsoft-excel-mangles-diacritics-in-csv-files\r\n    // Option#2: use a 3rd party extension to javascript encode into UTF-16\r\n    let outputData: Uint8Array | string;\r\n    if (options.format === FileType.csv) {\r\n      outputData = new TextEncoder('utf-8').encode(csvContent);\r\n    } else {\r\n      outputData = csvContent;\r\n    }\r\n\r\n    // create a Blob object for the download\r\n    const blob = new Blob([options.useUtf8WithBom ? '\\uFEFF' : '', outputData], {\r\n      type: `${mimeType};charset=utf-8;`\r\n    });\r\n\r\n    // when using IE/Edge, then use different download call\r\n    if (typeof navigator.msSaveOrOpenBlob === 'function') {\r\n      navigator.msSaveOrOpenBlob(blob, options.filename);\r\n    } else {\r\n      // this trick will generate a temp <a /> tag\r\n      // the code will then trigger a hidden click for it to start downloading\r\n      const link = document.createElement('a');\r\n      const csvUrl = URL.createObjectURL(blob);\r\n\r\n      link.textContent = 'download';\r\n      link.href = csvUrl;\r\n      link.setAttribute('download', options.filename);\r\n\r\n      // set the visibility to hidden so there is no effect on your web-layout\r\n      link.style.visibility = 'hidden';\r\n\r\n      // this part will append the anchor tag, trigger a click (for download to start) and finally remove the tag once completed\r\n      document.body.appendChild(link);\r\n      link.click();\r\n      document.body.removeChild(link);\r\n    }\r\n  }\r\n}\r\n",
    "export enum DelimiterType {\r\n  colon = ':',\r\n  comma = ',',\r\n  equalSign = '=',\r\n  pipe = '|',\r\n  semicolon = ';',\r\n  space = ' ',\r\n  tab = '\\t',\r\n\r\n  doubleColon = '::',\r\n  doublePipe = '||',\r\n  doubleSemicolon = ';;',\r\n}\r\n\r\n",
    "export enum FileType {\r\n  csv = 'csv',\r\n  doc = 'doc',\r\n  docx = 'docx',\r\n  pdf = 'pdf',\r\n  txt = 'txt',\r\n  xls = 'xls',\r\n  xlsx = 'xlsx'\r\n}\r\n",
    "export enum OperatorType {\r\n  contains = 'Contains',\r\n  lessThan = 'LT',\r\n  lessThanOrEqual = 'LE',\r\n  greaterThan = 'GT',\r\n  greaterThanOrEqual = 'GE',\r\n  notEqual = 'NE',\r\n  equal = 'EQ',\r\n  endsWith = 'EndsWith',\r\n  startsWith = 'StartsWith',\r\n  in = 'IN',\r\n  notIn = 'NIN'\r\n}\r\n",
    "import { FilterCondition, FilterConditionOption } from './../models/index';\r\n\r\nfunction parseBoolean(str: number | string) {\r\n  return /(true|1)/i.test(str + '');\r\n}\r\n\r\nexport const booleanFilterCondition: FilterCondition = (options: FilterConditionOption) => {\r\n  return parseBoolean(options.cellValue) === parseBoolean(options.searchTerm);\r\n};\r\n",
    "export const testFilterCondition = (operator: string, value1: any, value2: any): boolean => {\r\n  switch (operator) {\r\n    case '<':\r\n    case 'LT': return (value1 < value2);\r\n    case '<=':\r\n    case 'LE': return (value1 <= value2);\r\n    case '>':\r\n    case 'GT': return (value1 > value2);\r\n    case '>=':\r\n    case 'GE': return (value1 >= value2);\r\n    case '!=':\r\n    case '<>':\r\n    case 'NE': return (value1 !== value2);\r\n    case '=':\r\n    case '==':\r\n    case 'EQ': return (value1 === value2);\r\n    case 'IN': return ((value2 && value2.includes) ? (value2.includes(value1)) : false);\r\n  }\r\n  return true;\r\n};\r\n",
    "import { FieldType, FilterCondition, FilterConditionOption } from '../models/index';\r\nimport { mapMomentDateFormatWithFieldType } from './../services/utilities';\r\nimport { testFilterCondition } from './filterUtilities';\r\nimport * as moment_ from 'moment-mini';\r\nconst moment = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\n\r\nexport const dateFilterCondition: FilterCondition = (options: FilterConditionOption) => {\r\n  const filterSearchType = options.filterSearchType || FieldType.dateIso;\r\n  const searchDateFormat = mapMomentDateFormatWithFieldType(filterSearchType);\r\n  if (!moment(options.cellValue, moment.ISO_8601).isValid() || !moment(options.searchTerm, searchDateFormat, true).isValid()) {\r\n    return true;\r\n  }\r\n  const dateCell = moment(options.cellValue);\r\n  const dateSearch = moment(options.searchTerm);\r\n\r\n  // run the filter condition with date in Unix Timestamp format\r\n  return testFilterCondition(options.operator || '==', parseInt(dateCell.format('X'), 10), parseInt(dateSearch.format('X'), 10));\r\n};\r\n",
    "import { FieldType, FilterCondition, FilterConditionOption } from '../models/index';\r\nimport { testFilterCondition } from './filterUtilities';\r\nimport { mapMomentDateFormatWithFieldType } from './../services/utilities';\r\nimport * as moment_ from 'moment-mini';\r\nconst moment = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\nconst FORMAT = mapMomentDateFormatWithFieldType(FieldType.dateIso);\r\n\r\nexport const dateIsoFilterCondition: FilterCondition = (options: FilterConditionOption) => {\r\n  if (!moment(options.cellValue, FORMAT, true).isValid() || !moment(options.searchTerm, FORMAT, true).isValid()) {\r\n    return true;\r\n  }\r\n  const dateCell = moment(options.cellValue, FORMAT, true);\r\n  const dateSearch = moment(options.searchTerm, FORMAT, true);\r\n\r\n  // run the filter condition with date in Unix Timestamp format\r\n  return testFilterCondition(options.operator || '==', parseInt(dateCell.format('X'), 10), parseInt(dateSearch.format('X'), 10));\r\n};\r\n",
    "import { FieldType, FilterCondition, FilterConditionOption } from '../models/index';\r\nimport { testFilterCondition } from './filterUtilities';\r\nimport { mapMomentDateFormatWithFieldType } from './../services/utilities';\r\nimport * as moment_ from 'moment-mini';\r\nconst moment = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\nconst FORMAT = mapMomentDateFormatWithFieldType(FieldType.dateUs);\r\n\r\nexport const dateUsFilterCondition: FilterCondition = (options: FilterConditionOption) => {\r\n  if (!moment(options.cellValue, FORMAT, true).isValid() || !moment(options.searchTerm, FORMAT, true).isValid()) {\r\n    return true;\r\n  }\r\n  const dateCell = moment(options.cellValue, FORMAT, true);\r\n  const dateSearch = moment(options.searchTerm, FORMAT, true);\r\n\r\n  // run the filter condition with date in Unix Timestamp format\r\n  return testFilterCondition(options.operator || '==', parseInt(dateCell.format('X'), 10), parseInt(dateSearch.format('X'), 10));\r\n};\r\n",
    "import { FieldType, FilterCondition, FilterConditionOption } from '../models/index';\r\nimport { testFilterCondition } from './filterUtilities';\r\nimport { mapMomentDateFormatWithFieldType } from './../services/utilities';\r\nimport * as moment_ from 'moment-mini';\r\nconst moment = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\nconst FORMAT = mapMomentDateFormatWithFieldType(FieldType.dateUsShort);\r\n\r\nexport const dateUsShortFilterCondition: FilterCondition = (options: FilterConditionOption) => {\r\n  if (!moment(options.cellValue, FORMAT, true).isValid() || !moment(options.searchTerm, FORMAT, true).isValid()) {\r\n    return true;\r\n  }\r\n  const dateCell = moment(options.cellValue, FORMAT, true);\r\n  const dateSearch = moment(options.searchTerm, FORMAT, true);\r\n\r\n  // run the filter condition with date in Unix Timestamp format\r\n  return testFilterCondition(options.operator || '==', parseInt(dateCell.format('X'), 10), parseInt(dateSearch.format('X'), 10));\r\n};\r\n",
    "import { FilterCondition, FilterConditionOption } from '../models/index';\r\nimport { mapMomentDateFormatWithFieldType } from './../services/utilities';\r\nimport { testFilterCondition } from './filterUtilities';\r\nimport * as moment_ from 'moment-mini';\r\nconst moment = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\n\r\nexport const dateUtcFilterCondition: FilterCondition = (options: FilterConditionOption) => {\r\n  if (!options.filterSearchType) {\r\n    throw new Error('Date UTC filter is a special case and requires a filterSearchType to be provided in the column option, for example: { filterable: true, type: FieldType.dateUtc, filterSearchType: FieldType.dateIso }');\r\n  }\r\n\r\n  const searchDateFormat = mapMomentDateFormatWithFieldType(options.filterSearchType);\r\n  if (!moment(options.cellValue, moment.ISO_8601).isValid() || !moment(options.searchTerm, searchDateFormat, true).isValid()) {\r\n    return true;\r\n  }\r\n  const dateCell = moment(options.cellValue, moment.ISO_8601, true);\r\n  const dateSearch = moment(options.searchTerm, searchDateFormat, true);\r\n\r\n  // run the filter condition with date in Unix Timestamp format\r\n  return testFilterCondition(options.operator || '==', parseInt(dateCell.format('X'), 10), parseInt(dateSearch.format('X'), 10));\r\n};\r\n",
    "import { FilterCondition, FilterConditionOption } from '../models/index';\r\nimport { testFilterCondition } from './filterUtilities';\r\n\r\nexport const collectionSearchFilterCondition: FilterCondition = (options: FilterConditionOption) => {\r\n  // multiple-select will always return text, so we should make our cell values text as well\r\n  const cellValue = options.cellValue + '';\r\n\r\n  return testFilterCondition(options.operator || 'IN', cellValue, options.searchTerms || []);\r\n};\r\n",
    "import { FilterCondition, FilterConditionOption } from '../models/index';\r\nimport { testFilterCondition } from './filterUtilities';\r\n\r\nexport const numberFilterCondition: FilterCondition = (options: FilterConditionOption) => {\r\n  const cellValue = parseFloat(options.cellValue);\r\n  const searchTerm = (typeof options.searchTerm === 'string') ? parseFloat(options.searchTerm) : options.searchTerm;\r\n\r\n  return testFilterCondition(options.operator || '==', cellValue, searchTerm);\r\n};\r\n",
    "import { FilterCondition, FilterConditionOption } from '../models/index';\r\nimport { testFilterCondition } from './filterUtilities';\r\n\r\nexport const stringFilterCondition: FilterCondition = (options: FilterConditionOption) => {\r\n  // make sure the cell value is a string by casting it when possible\r\n  options.cellValue = (options.cellValue === undefined || options.cellValue === null) ? '' : options.cellValue.toString();\r\n\r\n  // make both the cell value and search value lower for case insensitive comparison\r\n  const cellValue = options.cellValue.toLowerCase();\r\n  const searchTerm = (typeof options.searchTerm === 'string') ? options.searchTerm.toLowerCase() : options.searchTerm;\r\n\r\n  if (options.operator === '*') {\r\n    return cellValue.endsWith(searchTerm);\r\n  } else if (options.operator === '' && options.cellValueLastChar === '*') {\r\n    return cellValue.startsWith(searchTerm);\r\n  } else if (options.operator === '') {\r\n    return cellValue.includes(searchTerm);\r\n  }\r\n  return testFilterCondition(options.operator || '==', cellValue, searchTerm);\r\n};\r\n",
    "import { booleanFilterCondition } from './booleanFilterCondition';\r\nimport { dateFilterCondition } from './dateFilterCondition';\r\nimport { dateIsoFilterCondition } from './dateIsoFilterCondition';\r\nimport { dateUsShortFilterCondition } from './dateUsShortFilterCondition';\r\nimport { dateUsFilterCondition } from './dateUsFilterCondition';\r\nimport { dateUtcFilterCondition } from './dateUtcFilterCondition';\r\nimport { FilterConditionOption } from './../models/filterConditionOption.interface';\r\nimport { FilterCondition } from '../models/filterCondition.interface';\r\nimport { collectionSearchFilterCondition } from './collectionSearchFilterCondition';\r\nimport { numberFilterCondition } from './numberFilterCondition';\r\nimport { stringFilterCondition } from './stringFilterCondition';\r\nimport { FieldType } from '../models/index';\r\n\r\nexport const executeMappedCondition: FilterCondition = (options: FilterConditionOption) => {\r\n  // when using a multi-select ('IN' operator) we will not use the field type but instead go directly with a collection search\r\n  if (options && options.operator && options.operator.toUpperCase() === 'IN') {\r\n    return collectionSearchFilterCondition(options);\r\n  }\r\n\r\n  // execute the mapped type, or default to String condition check\r\n  switch (options.fieldType) {\r\n    case FieldType.boolean:\r\n      return booleanFilterCondition(options);\r\n    case FieldType.date:\r\n      return dateFilterCondition(options);\r\n    case FieldType.dateUtc:\r\n      return dateUtcFilterCondition(options);\r\n    case FieldType.dateIso:\r\n      return dateIsoFilterCondition(options);\r\n    case FieldType.dateUs:\r\n    case FieldType.dateTimeUs:\r\n      return dateUsFilterCondition(options);\r\n    case FieldType.dateUsShort:\r\n    case FieldType.dateTimeUsShort:\r\n      return dateUsShortFilterCondition(options);\r\n    case FieldType.number:\r\n      return numberFilterCondition(options);\r\n    case FieldType.string:\r\n    default:\r\n      return stringFilterCondition(options);\r\n  }\r\n};\r\n",
    "import { FilterConditionOption } from './../models/filterConditionOption.interface';\r\nimport { booleanFilterCondition } from './booleanFilterCondition';\r\nimport { dateFilterCondition } from './dateFilterCondition';\r\nimport { dateIsoFilterCondition } from './dateIsoFilterCondition';\r\nimport { dateUsFilterCondition } from './dateUsFilterCondition';\r\nimport { dateUsShortFilterCondition } from './dateUsShortFilterCondition';\r\nimport { dateUtcFilterCondition } from './dateUtcFilterCondition';\r\nimport { executeMappedCondition } from './executeMappedCondition';\r\nimport { collectionSearchFilterCondition } from './collectionSearchFilterCondition';\r\nimport { numberFilterCondition } from './numberFilterCondition';\r\nimport { stringFilterCondition } from './stringFilterCondition';\r\nimport { testFilterCondition } from './filterUtilities';\r\n\r\nexport const FilterConditions = {\r\n  executeMappedCondition,\r\n  booleanFilter: booleanFilterCondition,\r\n  collectionSearchFilter: collectionSearchFilterCondition,\r\n  dateFilter: dateFilterCondition,\r\n  dateIsoFilter: dateIsoFilterCondition,\r\n  dateUtcFilter: dateUtcFilterCondition,\r\n  dateUsFilter: dateUsFilterCondition,\r\n  dateUsShortFilter: dateUsShortFilterCondition,\r\n  numberFilter: numberFilterCondition,\r\n  stringFilter: stringFilterCondition,\r\n  testFilter: testFilterCondition\r\n};\r\n",
    "import { Column, Filter, FilterArguments, FilterCallback, SearchTerm } from './../models/index';\r\nimport $ from 'jquery';\r\n\r\n// using external non-typed js libraries\r\ndeclare var $: any;\r\n\r\nexport class InputFilter implements Filter {\r\n  private $filterElm: any;\r\n  grid: any;\r\n  searchTerm: SearchTerm;\r\n  columnDef: Column;\r\n  callback: FilterCallback;\r\n\r\n  constructor() {}\r\n\r\n  /**\r\n   * Initialize the Filter\r\n   */\r\n  init(args: FilterArguments) {\r\n    this.grid = args.grid;\r\n    this.callback = args.callback;\r\n    this.columnDef = args.columnDef;\r\n    this.searchTerm = args.searchTerm;\r\n\r\n    // step 1, create HTML string template\r\n    const filterTemplate = this.buildTemplateHtmlString();\r\n\r\n    // step 2, create the DOM Element of the filter & initialize it if searchTerm is filled\r\n    this.$filterElm = this.createDomElement(filterTemplate);\r\n\r\n    // step 3, subscribe to the keyup event and run the callback when that happens\r\n    // also add/remove \"filled\" class for styling purposes\r\n    this.$filterElm.keyup((e: any) => {\r\n      (e && e.target && e.target.value) ? this.$filterElm.addClass('filled') : this.$filterElm.removeClass('filled');\r\n      this.callback(e, { columnDef: this.columnDef });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Clear the filter value\r\n   */\r\n  clear(triggerFilterKeyup = true) {\r\n    if (this.$filterElm) {\r\n      this.$filterElm.val('');\r\n      if (triggerFilterKeyup) {\r\n        this.$filterElm.trigger('keyup');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * destroy the filter\r\n   */\r\n  destroy() {\r\n    if (this.$filterElm) {\r\n      this.$filterElm.off('keyup').remove();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set value(s) on the DOM element\r\n   */\r\n  setValues(values: SearchTerm) {\r\n    if (values) {\r\n      this.$filterElm.val(values);\r\n    }\r\n  }\r\n\r\n  //\r\n  // private functions\r\n  // ------------------\r\n\r\n  /**\r\n   * Create the HTML template as a string\r\n   */\r\n  private buildTemplateHtmlString() {\r\n    return `<input type=\"text\" class=\"form-control search-filter\" style=\"font-family: Segoe UI Symbol;\" placeholder=\"&#128269;\">`;\r\n  }\r\n\r\n  /**\r\n   * From the html template string, create a DOM element\r\n   * @param filterTemplate\r\n   */\r\n  private createDomElement(filterTemplate: string) {\r\n    const $headerElm = this.grid.getHeaderRowColumn(this.columnDef.id);\r\n    $($headerElm).empty();\r\n\r\n    // create the DOM element & add an ID and filter class\r\n    const $filterElm = $(filterTemplate);\r\n    const searchTerm = (typeof this.searchTerm === 'boolean') ? `${this.searchTerm}` : this.searchTerm;\r\n    $filterElm.val(searchTerm);\r\n    $filterElm.attr('id', `filter-${this.columnDef.id}`);\r\n    $filterElm.data('columnId', this.columnDef.id);\r\n\r\n    // if there's a search term, we will add the \"filled\" class for styling purposes\r\n    if (this.searchTerm) {\r\n      $filterElm.addClass('filled');\r\n    }\r\n\r\n    // append the new DOM element to the header row\r\n    if ($filterElm && typeof $filterElm.appendTo === 'function') {\r\n      $filterElm.appendTo($headerElm);\r\n    }\r\n\r\n    return $filterElm;\r\n  }\r\n}\r\n",
    "import { Injectable } from '@angular/core';\r\nimport { TranslateService } from '@ngx-translate/core';\r\nimport { Column, Filter, FilterArguments, FilterCallback, MultipleSelectOption, SearchTerm, SelectOption } from './../models/index';\r\nimport $ from 'jquery';\r\n\r\n// using external non-typed js libraries\r\ndeclare var $: any;\r\n\r\n@Injectable()\r\nexport class MultipleSelectFilter implements Filter {\r\n  $filterElm: any;\r\n  grid: any;\r\n  searchTerms: SearchTerm[];\r\n  columnDef: Column;\r\n  callback: FilterCallback;\r\n  defaultOptions: MultipleSelectOption;\r\n  isFilled = false;\r\n\r\n  /**\r\n   * Initialize the Filter\r\n   */\r\n  constructor(private translate: TranslateService) {\r\n    // default options used by this Filter, user can overwrite any of these by passing \"otions\"\r\n    this.defaultOptions = {\r\n      container: 'body',\r\n      filter: false,  // input search term on top of the select option list\r\n      maxHeight: 200,\r\n      okButton: true,\r\n      addTitle: true, // show tooltip of all selected items while hovering the filter\r\n      countSelected: this.translate.instant('X_OF_Y_SELECTED'),\r\n      allSelected: this.translate.instant('ALL_SELECTED'),\r\n      selectAllText: this.translate.instant('SELECT_ALL'),\r\n      selectAllDelimiter: ['', ''], // remove default square brackets of default text \"[Select All]\" => \"Select All\"\r\n\r\n      // we will subscribe to the onClose event for triggering our callback\r\n      // also add/remove \"filled\" class for styling purposes\r\n      onClose: () => {\r\n        const selectedItems = this.$filterElm.multipleSelect('getSelects');\r\n        if (Array.isArray(selectedItems) && selectedItems.length > 0) {\r\n          this.isFilled = true;\r\n          this.$filterElm.addClass('filled').siblings('div .search-filter').addClass('filled');\r\n        } else {\r\n          this.isFilled = false;\r\n          this.$filterElm.removeClass('filled').siblings('div .search-filter').removeClass('filled');\r\n        }\r\n        this.callback(undefined, { columnDef: this.columnDef, operator: 'IN', searchTerms: selectedItems });\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Initialize the filter template\r\n   */\r\n  init(args: FilterArguments) {\r\n    this.grid = args.grid;\r\n    this.callback = args.callback;\r\n    this.columnDef = args.columnDef;\r\n    this.searchTerms = args.searchTerms || [];\r\n\r\n    // step 1, create HTML string template\r\n    const filterTemplate = this.buildTemplateHtmlString();\r\n\r\n    // step 2, create the DOM Element of the filter & pre-load search terms\r\n    // also subscribe to the onClose event\r\n    this.createDomElement(filterTemplate);\r\n  }\r\n\r\n  /**\r\n   * Clear the filter values\r\n   */\r\n  clear(triggerFilterChange = true) {\r\n    if (this.$filterElm && this.$filterElm.multipleSelect) {\r\n      // reload the filter element by it's id, to make sure it's still a valid element (because of some issue in the GraphQL example)\r\n      // this.$filterElm = $(`#${this.$filterElm[0].id}`);\r\n      this.$filterElm.multipleSelect('setSelects', []);\r\n\r\n      if (triggerFilterChange) {\r\n        this.$filterElm.removeClass('filled');\r\n        this.callback(undefined, { columnDef: this.columnDef, operator: 'IN', searchTerms: [] });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * destroy the filter\r\n   */\r\n  destroy() {\r\n    if (this.$filterElm) {\r\n      this.$filterElm.off().remove();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set value(s) on the DOM element\r\n   */\r\n  setValues(values: SearchTerm[]) {\r\n    if (values) {\r\n      this.$filterElm.multipleSelect('setSelects', values);\r\n    }\r\n  }\r\n\r\n  //\r\n  // private functions\r\n  // ------------------\r\n\r\n  /**\r\n   * Create the HTML template as a string\r\n   */\r\n  private buildTemplateHtmlString() {\r\n    if (!this.columnDef || !this.columnDef.filter || !this.columnDef.filter.collection) {\r\n      throw new Error(`[Angular-SlickGrid] You need to pass a \"collection\" for the MultipleSelect Filter to work correctly. Also each option should include a value/label pair (or value/labelKey when using Locale). For example:: { filter: type: FilterType.multipleSelect, collection: [{ value: true, label: 'True' }, { value: false, label: 'False'}] }`);\r\n    }\r\n    const optionCollection = this.columnDef.filter.collection || [];\r\n    const labelName = (this.columnDef.filter.customStructure) ? this.columnDef.filter.customStructure.label : 'label';\r\n    const valueName = (this.columnDef.filter.customStructure) ? this.columnDef.filter.customStructure.value : 'value';\r\n\r\n    let options = '';\r\n    optionCollection.forEach((option: SelectOption) => {\r\n      if (!option || (option[labelName] === undefined && option.labelKey === undefined)) {\r\n        throw new Error(`A collection with value/label (or value/labelKey when using Locale) is required to populate the Select list, for example:: { filter: type: FilterType.multipleSelect, collection: [ { value: '1', label: 'One' } ]')`);\r\n      }\r\n      const labelKey = (option.labelKey || option[labelName]) as string;\r\n      const selected = (this.findValueInSearchTerms(option[valueName]) >= 0) ? 'selected' : '';\r\n      const textLabel = ((option.labelKey || this.columnDef.filter.enableTranslateLabel) && this.translate && typeof this.translate.instant === 'function') ? this.translate.instant(labelKey || ' ') : labelKey;\r\n\r\n      // html text of each select option\r\n      options += `<option value=\"${option[valueName]}\" ${selected}>${textLabel}</option>`;\r\n\r\n      // if there's a search term, we will add the \"filled\" class for styling purposes\r\n      if (selected) {\r\n        this.isFilled = true;\r\n      }\r\n    });\r\n\r\n    return `<select class=\"ms-filter search-filter\" multiple=\"multiple\">${options}</select>`;\r\n  }\r\n\r\n  /**\r\n   * From the html template string, create a DOM element\r\n   * Subscribe to the onClose event and run the callback when that happens\r\n   * @param filterTemplate\r\n   */\r\n  private createDomElement(filterTemplate: string) {\r\n    const $headerElm = this.grid.getHeaderRowColumn(this.columnDef.id);\r\n    $($headerElm).empty();\r\n\r\n    // create the DOM element & add an ID and filter class\r\n    this.$filterElm = $(filterTemplate);\r\n    if (typeof this.$filterElm.multipleSelect !== 'function') {\r\n      throw new Error(`multiple-select.js was not found, make sure to modify your \"angular-cli.json\" file and include \"../node_modules/angular-slickgrid/lib/multiple-select/multiple-select.js\" and it's css or SASS file`);\r\n    }\r\n    this.$filterElm.attr('id', `filter-${this.columnDef.id}`);\r\n    this.$filterElm.data('columnId', this.columnDef.id);\r\n\r\n    // if there's a search term, we will add the \"filled\" class for styling purposes\r\n    if (this.isFilled) {\r\n      this.$filterElm.addClass('filled');\r\n    }\r\n\r\n    // append the new DOM element to the header row\r\n    if (this.$filterElm && typeof this.$filterElm.appendTo === 'function') {\r\n      this.$filterElm.appendTo($headerElm);\r\n    }\r\n\r\n    // merge options & attach multiSelect\r\n    const options: MultipleSelectOption = { ...this.defaultOptions, ...this.columnDef.filter.filterOptions };\r\n    this.$filterElm = this.$filterElm.multipleSelect(options);\r\n  }\r\n\r\n  private findValueInSearchTerms(value: number | string): number {\r\n    if (this.searchTerms && Array.isArray(this.searchTerms)) {\r\n      for (let i = 0; i < this.searchTerms.length; i++) {\r\n        if (this.searchTerms[i] && this.searchTerms[i] === value) {\r\n          return i;\r\n        }\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n}\r\n",
    "import { TranslateService } from '@ngx-translate/core';\r\nimport { Column, Filter, FilterArguments, FilterCallback, SearchTerm } from './../models/index';\r\nimport $ from 'jquery';\r\n\r\n// using external non-typed js libraries\r\ndeclare var $: any;\r\n\r\nexport class SelectFilter implements Filter {\r\n  $filterElm: any;\r\n  grid: any;\r\n  searchTerm: SearchTerm;\r\n  columnDef: Column;\r\n  callback: FilterCallback;\r\n\r\n  constructor(private translate: TranslateService) {}\r\n\r\n  /**\r\n   * Initialize the Filter\r\n   */\r\n  init(args: FilterArguments) {\r\n    this.grid = args.grid;\r\n    this.callback = args.callback;\r\n    this.columnDef = args.columnDef;\r\n    this.searchTerm = args.searchTerm;\r\n\r\n    // step 1, create HTML string template\r\n    const filterTemplate = this.buildTemplateHtmlString();\r\n\r\n    // step 2, create the DOM Element of the filter & initialize it if searchTerm is filled\r\n    this.$filterElm = this.createDomElement(filterTemplate);\r\n\r\n    // step 3, subscribe to the change event and run the callback when that happens\r\n    // also add/remove \"filled\" class for styling purposes\r\n    this.$filterElm.change((e: any) => {\r\n      (e && e.target && e.target.value) ? this.$filterElm.addClass('filled') : this.$filterElm.removeClass('filled');\r\n      this.callback(e, { columnDef: this.columnDef, operator: 'EQ' });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Clear the filter values\r\n   */\r\n  clear(triggerFilterChange = true) {\r\n    if (this.$filterElm) {\r\n      this.$filterElm.val('');\r\n      if (triggerFilterChange) {\r\n        this.$filterElm.trigger('change');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * destroy the filter\r\n   */\r\n  destroy() {\r\n    if (this.$filterElm) {\r\n      this.$filterElm.off('change').remove();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set value(s) on the DOM element\r\n   */\r\n  setValues(values: SearchTerm | SearchTerm[]) {\r\n    if (values) {\r\n      this.$filterElm.val(values);\r\n    }\r\n  }\r\n\r\n  //\r\n  // private functions\r\n  // ------------------\r\n\r\n  private buildTemplateHtmlString() {\r\n    if (!this.columnDef || !this.columnDef.filter || (!this.columnDef.filter.collection && !this.columnDef.filter.selectOptions)) {\r\n      throw new Error(`[Angular-SlickGrid] You need to pass a \"collection\" for the Select Filter to work correctly. Also each option should include a value/label pair (or value/labelKey when using Locale). For example:: { filter: type: FilterType.select, collection: [{ value: true, label: 'True' }, { value: false, label: 'False'}] }`);\r\n    }\r\n    if (!this.columnDef.filter.collection && this.columnDef.filter.selectOptions) {\r\n      console.warn(`[Angular-SlickGrid] The Select Filter \"selectOptions\" property will de deprecated in future version. Please use the new \"collection\" property which is more generic and can be used with other Filters (not just Select).`);\r\n    }\r\n\r\n    const optionCollection = this.columnDef.filter.collection || this.columnDef.filter.selectOptions || [];\r\n    const labelName = (this.columnDef.filter.customStructure) ? this.columnDef.filter.customStructure.label : 'label';\r\n    const valueName = (this.columnDef.filter.customStructure) ? this.columnDef.filter.customStructure.value : 'value';\r\n\r\n    let options = '';\r\n    optionCollection.forEach((option: any) => {\r\n      if (!option || (option[labelName] === undefined && option.labelKey === undefined)) {\r\n        throw new Error(`A collection with value/label (or value/labelKey when using Locale) is required to populate the Select list, for example:: { filter: type: FilterType.select, collection: [ { value: '1', label: 'One' } ]')`);\r\n      }\r\n      const labelKey = option.labelKey || option[labelName];\r\n      const textLabel = ((option.labelKey || this.columnDef.filter.enableTranslateLabel) && this.translate && typeof this.translate.instant === 'function') ? this.translate.instant(labelKey || ' ') : labelKey;\r\n      options += `<option value=\"${option[valueName]}\">${textLabel}</option>`;\r\n    });\r\n    return `<select class=\"form-control search-filter\">${options}</select>`;\r\n  }\r\n\r\n  /**\r\n   * From the html template string, create a DOM element\r\n   * @param filterTemplate\r\n   */\r\n  private createDomElement(filterTemplate: string) {\r\n    const $headerElm = this.grid.getHeaderRowColumn(this.columnDef.id);\r\n    $($headerElm).empty();\r\n\r\n    // create the DOM element & add an ID and filter class\r\n    const $filterElm = $(filterTemplate);\r\n    const searchTerm = (typeof this.searchTerm === 'boolean') ? `${this.searchTerm}` : this.searchTerm;\r\n    $filterElm.val(searchTerm);\r\n    $filterElm.attr('id', `filter-${this.columnDef.id}`);\r\n    $filterElm.data('columnId', this.columnDef.id);\r\n\r\n    // append the new DOM element to the header row\r\n    if ($filterElm && typeof $filterElm.appendTo === 'function') {\r\n      $filterElm.appendTo($headerElm);\r\n    }\r\n\r\n    return $filterElm;\r\n  }\r\n}\r\n",
    "import { TranslateService } from '@ngx-translate/core';\r\nimport { Column, Filter, FilterArguments, FilterCallback, MultipleSelectOption, SearchTerm, SelectOption } from './../models/index';\r\nimport $ from 'jquery';\r\nimport { Injectable } from '@angular/core';\r\n\r\n// using external non-typed js libraries\r\ndeclare var $: any;\r\n\r\n@Injectable()\r\nexport class SingleSelectFilter implements Filter {\r\n  $filterElm: any;\r\n  grid: any;\r\n  searchTerm: SearchTerm;\r\n  columnDef: Column;\r\n  callback: FilterCallback;\r\n  defaultOptions: MultipleSelectOption;\r\n\r\n  constructor(private translate: TranslateService) {\r\n    // default options used by this Filter, user can overwrite any of these by passing \"otions\"\r\n    this.defaultOptions = {\r\n      container: 'body',\r\n      filter: false,  // input search term on top of the select option list\r\n      maxHeight: 200,\r\n      single: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Initialize the Filter\r\n   */\r\n  init(args: FilterArguments) {\r\n    this.grid = args.grid;\r\n    this.callback = args.callback;\r\n    this.columnDef = args.columnDef;\r\n    this.searchTerm = args.searchTerm;\r\n\r\n    // step 1, create HTML string template\r\n    const filterTemplate = this.buildTemplateHtmlString();\r\n\r\n    // step 2, create the DOM Element of the filter & pre-load search term\r\n    this.createDomElement(filterTemplate);\r\n\r\n    // step 3, subscribe to the change event and run the callback when that happens\r\n    // also add/remove \"filled\" class for styling purposes\r\n    this.$filterElm.change((e: any) => {\r\n      if (e && e.target && e.target.value) {\r\n        this.$filterElm.addClass('filled').siblings('div .search-filter').addClass('filled') ;\r\n      } else {\r\n        this.$filterElm.removeClass('filled').siblings('div .search-filter').removeClass('filled');\r\n      }\r\n      this.callback(e, { columnDef: this.columnDef, operator: 'EQ' });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Clear the filter values\r\n   */\r\n  clear(triggerFilterChange = true) {\r\n    if (this.$filterElm && this.$filterElm.multipleSelect) {\r\n      // reload the filter element by it's id, to make sure it's still a valid element (because of some issue in the GraphQL example)\r\n      // this.$filterElm = $(`#${this.$filterElm[0].id}`);\r\n      this.$filterElm.multipleSelect('setSelects', []);\r\n\r\n      if (triggerFilterChange) {\r\n        this.callback(undefined, { columnDef: this.columnDef, operator: 'IN', searchTerm: undefined });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * destroy the filter\r\n   */\r\n  destroy() {\r\n    if (this.$filterElm) {\r\n      this.$filterElm.off().remove();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set value(s) on the DOM element\r\n   */\r\n  setValues(values: SearchTerm | SearchTerm[]) {\r\n    if (values) {\r\n      values = Array.isArray(values) ? values : [values];\r\n      this.$filterElm.multipleSelect('setSelects', values);\r\n    }\r\n  }\r\n\r\n  //\r\n  // private functions\r\n  // ------------------\r\n\r\n  /**\r\n   * Create the HTML template as a string\r\n   */\r\n  private buildTemplateHtmlString() {\r\n    if (!this.columnDef || !this.columnDef.filter || !this.columnDef.filter.collection) {\r\n      throw new Error(`[Angular-SlickGrid] You need to pass a \"collection\" for the SingleSelect Filter to work correctly. Also each option should include a value/label pair (or value/labelKey when using Locale). For example:: { filter: type: FilterType.singleSelect, collection: [{ value: true, label: 'True' }, { value: false, label: 'False'}] }`);\r\n    }\r\n    const optionCollection = this.columnDef.filter.collection || [];\r\n    const labelName = (this.columnDef.filter.customStructure) ? this.columnDef.filter.customStructure.label : 'label';\r\n    const valueName = (this.columnDef.filter.customStructure) ? this.columnDef.filter.customStructure.value : 'value';\r\n\r\n    let options = '';\r\n    optionCollection.forEach((option: SelectOption) => {\r\n      if (!option || (option[labelName] === undefined && option.labelKey === undefined)) {\r\n        throw new Error(`A collection with value/label (or value/labelKey when using Locale) is required to populate the Select list, for example:: { filter: type: FilterType.singleSelect, collection: [ { value: '1', label: 'One' } ]')`);\r\n      }\r\n\r\n      const labelKey = (option.labelKey || option[labelName]) as string;\r\n      const selected = (option[valueName] === this.searchTerm) ? 'selected' : '';\r\n      const textLabel = ((option.labelKey || this.columnDef.filter.enableTranslateLabel) && this.translate && typeof this.translate.instant === 'function') ? this.translate.instant(labelKey || ' ') : labelKey;\r\n\r\n      // html text of each select option\r\n      options += `<option value=\"${option[valueName]}\" ${selected}>${textLabel}</option>`;\r\n    });\r\n\r\n    return `<select class=\"ms-filter search-filter\">${options}</select>`;\r\n  }\r\n\r\n  /**\r\n   * From the html template string, create a DOM element\r\n   * Subscribe to the onClose event and run the callback when that happens\r\n   * @param filterTemplate\r\n   */\r\n  private createDomElement(filterTemplate: string) {\r\n    const $headerElm = this.grid.getHeaderRowColumn(this.columnDef.id);\r\n    $($headerElm).empty();\r\n\r\n    // create the DOM element & add an ID and filter class\r\n    this.$filterElm = $(filterTemplate);\r\n    if (typeof this.$filterElm.multipleSelect !== 'function') {\r\n      throw new Error(`multiple-select.js was not found, make sure to modify your \"angular-cli.json\" file and include \"../node_modules/angular-slickgrid/lib/multiple-select/multiple-select.js\" and it's css or SASS file`);\r\n    }\r\n    this.$filterElm.attr('id', `filter-${this.columnDef.id}`);\r\n    this.$filterElm.data('columnId', this.columnDef.id);\r\n\r\n    // append the new DOM element to the header row\r\n    if (this.$filterElm && typeof this.$filterElm.appendTo === 'function') {\r\n      this.$filterElm.appendTo($headerElm);\r\n    }\r\n\r\n    // merge options & attach multiSelect\r\n    const options: MultipleSelectOption = { ...this.defaultOptions, ...this.columnDef.filter.filterOptions };\r\n    this.$filterElm = this.$filterElm.multipleSelect(options);\r\n  }\r\n}\r\n",
    "import { Column, Filter } from './../models/index';\r\nimport { InputFilter } from './inputFilter';\r\nimport { MultipleSelectFilter } from './multipleSelectFilter';\r\nimport { SelectFilter } from './selectFilter';\r\nimport { SingleSelectFilter } from './singleSelectFilter';\r\n\r\nexport const Filters = {\r\n  input: InputFilter,\r\n  multipleSelect: MultipleSelectFilter,\r\n  singleSelect: SingleSelectFilter,\r\n  select: SelectFilter\r\n};\r\n",
    "import { DelimiterType } from './../models/delimiterType.enum';\r\nimport { ExportService } from './export.service';\r\nimport { Injectable } from '@angular/core';\r\nimport { FilterService } from './filter.service';\r\nimport {\r\n  CellArgs,\r\n  CustomGridMenu,\r\n  Column,\r\n  GraphqlResult,\r\n  GridMenu,\r\n  GridOption,\r\n  HeaderButtonOnCommandArgs,\r\n  HeaderMenuOnCommandArgs,\r\n  HeaderMenuOnBeforeMenuShowArgs,\r\n  FileType\r\n} from './../models/index';\r\nimport $ from 'jquery';\r\nimport { TranslateService } from '@ngx-translate/core';\r\nimport { castToPromise } from './../services/utilities';\r\n\r\n// using external non-typed js libraries\r\ndeclare var Slick: any;\r\ndeclare var $: any;\r\n\r\n@Injectable()\r\nexport class ControlAndPluginService {\r\n  private _dataView: any;\r\n  private _grid: any;\r\n  private _gridOptions: GridOption;\r\n  private _columnDefinitions: Column[];\r\n  visibleColumns: Column[];\r\n\r\n  // controls & plugins\r\n  autoTooltipPlugin: any;\r\n  checkboxSelectorPlugin: any;\r\n  columnPickerControl: any;\r\n  headerButtonsPlugin: any;\r\n  headerMenuPlugin: any;\r\n  gridMenuControl: any;\r\n  rowSelectionPlugin: any;\r\n\r\n  constructor(private exportService: ExportService, private filterService: FilterService, private translate: TranslateService) { }\r\n\r\n  /**\r\n   * Attach/Create different Controls or Plugins after the Grid is created\r\n   * @param grid\r\n   * @param columnDefinitions\r\n   * @param options\r\n   * @param dataView\r\n   */\r\n  attachDifferentControlOrPlugins(grid: any, columnDefinitions: Column[], options: GridOption, dataView: any) {\r\n    this._grid = grid;\r\n    this._gridOptions = options;\r\n    this._dataView = dataView;\r\n    this._columnDefinitions = columnDefinitions;\r\n    this.visibleColumns = columnDefinitions;\r\n\r\n    if (options.enableColumnPicker) {\r\n      this.columnPickerControl = this.createColumnPicker(grid, columnDefinitions, options);\r\n    }\r\n    if (options.enableGridMenu) {\r\n      this.gridMenuControl = this.createGridMenu(grid, columnDefinitions, options);\r\n    }\r\n    if (options.enableAutoTooltip) {\r\n      this.autoTooltipPlugin = new Slick.AutoTooltips(options.autoTooltipOptions || {});\r\n      grid.registerPlugin(this.autoTooltipPlugin);\r\n    }\r\n\r\n    if (options.enableCheckboxSelector) {\r\n      // when enabling the Checkbox Selector Plugin, we need to also watch onClick events to perform certain actions\r\n      // the selector column has to be create BEFORE the grid (else it behaves oddly), but we can only watch grid events AFTER the grid is created\r\n      grid.registerPlugin(this.checkboxSelectorPlugin);\r\n\r\n      // this also requires the Row Selection Model to be registered as well\r\n      if (!this.rowSelectionPlugin) {\r\n        this.rowSelectionPlugin = new Slick.RowSelectionModel(options.rowSelectionOptions || {});\r\n        grid.setSelectionModel(this.rowSelectionPlugin);\r\n      }\r\n    }\r\n    if (options.enableRowSelection) {\r\n      this.rowSelectionPlugin = new Slick.RowSelectionModel(options.rowSelectionOptions || {});\r\n      grid.setSelectionModel(this.rowSelectionPlugin);\r\n    }\r\n    if (options.enableHeaderButton) {\r\n      this.headerButtonsPlugin = new Slick.Plugins.HeaderButtons(options.headerButton || {});\r\n      grid.registerPlugin(this.headerButtonsPlugin);\r\n      this.headerButtonsPlugin.onCommand.subscribe((e: Event, args: HeaderButtonOnCommandArgs) => {\r\n        if (options.headerButton && typeof options.headerButton.onCommand === 'function') {\r\n          options.headerButton.onCommand(e, args);\r\n        }\r\n      });\r\n    }\r\n    if (options.enableHeaderMenu) {\r\n      const headerMenuOptions = options.headerMenu || {};\r\n      headerMenuOptions.minWidth = headerMenuOptions.minWidth || 140;\r\n      headerMenuOptions.autoAlignOffset = headerMenuOptions.autoAlignOffset || 12;\r\n      this.headerMenuPlugin = new Slick.Plugins.HeaderMenu(headerMenuOptions);\r\n      grid.registerPlugin(this.headerMenuPlugin);\r\n      this.headerMenuPlugin.onCommand.subscribe((e: Event, args: HeaderMenuOnCommandArgs) => {\r\n        if (options.headerMenu && typeof options.headerMenu.onCommand === 'function') {\r\n          options.headerMenu.onCommand(e, args);\r\n        }\r\n      });\r\n      this.headerMenuPlugin.onCommand.subscribe((e: Event, args: HeaderMenuOnBeforeMenuShowArgs) => {\r\n        if (options.headerMenu && typeof options.headerMenu.onBeforeMenuShow === 'function') {\r\n          options.headerMenu.onBeforeMenuShow(e, args);\r\n        }\r\n      });\r\n    }\r\n    if (options.registerPlugins !== undefined) {\r\n      if (Array.isArray(options.registerPlugins)) {\r\n        options.registerPlugins.forEach((plugin) => {\r\n          grid.registerPlugin(plugin);\r\n        });\r\n      } else {\r\n        grid.registerPlugin(options.registerPlugins);\r\n      }\r\n    }\r\n  }\r\n\r\n  createColumnPicker(grid: any, columnDefinitions: Column[], options: GridOption) {\r\n    // localization support for the picker\r\n    const forceFitTitle = options.enableTranslate ? this.translate.instant('FORCE_FIT_COLUMNS') : 'Force fit columns';\r\n    const syncResizeTitle = options.enableTranslate ? this.translate.instant('SYNCHRONOUS_RESIZE') : 'Synchronous resize';\r\n\r\n    options.columnPicker = options.columnPicker || {};\r\n    options.columnPicker.forceFitTitle = options.columnPicker.forceFitTitle || forceFitTitle;\r\n    options.columnPicker.syncResizeTitle = options.columnPicker.syncResizeTitle || syncResizeTitle;\r\n\r\n    this.columnPickerControl = new Slick.Controls.ColumnPicker(columnDefinitions, grid, options);\r\n    if (grid && options.enableColumnPicker) {\r\n      this.columnPickerControl.onColumnsChanged.subscribe((e: Event, args: CellArgs) => {\r\n        if (options.columnPicker && typeof options.columnPicker.onColumnsChanged === 'function') {\r\n          options.columnPicker.onColumnsChanged(e, args);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create (or re-create) Grid Menu and expose all the available hooks that user can subscribe (onCommand, onMenuClose, ...)\r\n   * @param grid\r\n   * @param columnDefinitions\r\n   * @param options\r\n   */\r\n  createGridMenu(grid: any, columnDefinitions: Column[], options: GridOption) {\r\n    options.gridMenu = { ...this.getDefaultGridMenuOptions(), ...options.gridMenu };\r\n    this.addGridMenuCustomCommands(grid, options);\r\n\r\n    const gridMenuControl = new Slick.Controls.GridMenu(columnDefinitions, grid, options);\r\n    if (grid && options.gridMenu) {\r\n      gridMenuControl.onBeforeMenuShow.subscribe((e: Event, args: CellArgs) => {\r\n        if (options.gridMenu && typeof options.gridMenu.onBeforeMenuShow === 'function') {\r\n          options.gridMenu.onBeforeMenuShow(e, args);\r\n        }\r\n      });\r\n      gridMenuControl.onColumnsChanged.subscribe((e: Event, args: CellArgs) => {\r\n        if (options.gridMenu && typeof options.gridMenu.onColumnsChanged === 'function') {\r\n          options.gridMenu.onColumnsChanged(e, args);\r\n        }\r\n      });\r\n      gridMenuControl.onCommand.subscribe((e: Event, args: CellArgs) => {\r\n        if (options.gridMenu && typeof options.gridMenu.onCommand === 'function') {\r\n          options.gridMenu.onCommand(e, args);\r\n        }\r\n      });\r\n      gridMenuControl.onMenuClose.subscribe((e: Event, args: CellArgs) => {\r\n        if (options.gridMenu && typeof options.gridMenu.onMenuClose === 'function') {\r\n          options.gridMenu.onMenuClose(e, args);\r\n        }\r\n\r\n        // we also want to resize the columns if the user decided to hide certain column(s)\r\n        if (grid && typeof grid.autosizeColumns === 'function') {\r\n          // make sure that the grid still exist (by looking if the Grid UID is found in the DOM tree)\r\n          const gridUid = grid.getUID();\r\n          if (gridUid && $(`.${gridUid}`).length > 0) {\r\n            grid.autosizeColumns();\r\n          }\r\n        }\r\n      });\r\n    }\r\n    return gridMenuControl;\r\n  }\r\n\r\n  hideColumn(column: Column) {\r\n    if (this._grid && this.visibleColumns) {\r\n      const columnIndex = this._grid.getColumnIndex(column.id);\r\n      this.visibleColumns = this.removeColumnByIndex(this.visibleColumns, columnIndex);\r\n      this._grid.setColumns(this.visibleColumns);\r\n    }\r\n  }\r\n\r\n  removeColumnByIndex(array: any[], index: number) {\r\n    return array.filter((el: any, i: number) => {\r\n      return index !== i;\r\n    });\r\n  }\r\n\r\n  autoResizeColumns() {\r\n    this._grid.autosizeColumns();\r\n  }\r\n\r\n  dispose() {\r\n    this._grid = null;\r\n    this._dataView = null;\r\n    this.visibleColumns = [];\r\n\r\n    if (this.columnPickerControl) {\r\n      this.columnPickerControl.destroy();\r\n      this.columnPickerControl = null;\r\n    }\r\n    if (this.gridMenuControl) {\r\n      this.gridMenuControl.destroy();\r\n      this.gridMenuControl = null;\r\n    }\r\n    if (this.rowSelectionPlugin) {\r\n      this.rowSelectionPlugin.destroy();\r\n      this.rowSelectionPlugin = null;\r\n    }\r\n    if (this.checkboxSelectorPlugin) {\r\n      this.checkboxSelectorPlugin.destroy();\r\n      this.checkboxSelectorPlugin = null;\r\n    }\r\n    if (this.autoTooltipPlugin) {\r\n      this.autoTooltipPlugin.destroy();\r\n      this.autoTooltipPlugin = null;\r\n    }\r\n    if (this.headerButtonsPlugin) {\r\n      this.headerButtonsPlugin.destroy();\r\n      this.headerButtonsPlugin = null;\r\n    }\r\n    if (this.headerMenuPlugin) {\r\n      this.headerMenuPlugin.destroy();\r\n      this.headerMenuPlugin = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create Grid Menu with Custom Commands if user has enabled Filters and/or uses a Backend Service (OData, GraphQL)\r\n   * @param grid\r\n   * @param options\r\n   */\r\n  private addGridMenuCustomCommands(grid: any, options: GridOption) {\r\n    const backendApi = options.backendServiceApi || options.onBackendEventApi || null;\r\n\r\n    if (options.enableFiltering) {\r\n      // show grid menu: clear all filters\r\n      if (options && options.gridMenu && options.gridMenu.showClearAllFiltersCommand && options.gridMenu.customItems && options.gridMenu.customItems.filter((item: CustomGridMenu) => item.command === 'clear-filter').length === 0) {\r\n        options.gridMenu.customItems.push(\r\n          {\r\n            iconCssClass: 'fa fa-filter text-danger',\r\n            title: options.enableTranslate ? this.translate.instant('CLEAR_ALL_FILTERS') : 'Clear All Filters',\r\n            disabled: false,\r\n            command: 'clear-filter',\r\n            positionOrder: 50\r\n          }\r\n        );\r\n      }\r\n      // show grid menu: toggle filter row\r\n      if (options && options.gridMenu && options.gridMenu.showToggleFilterCommand && options.gridMenu.customItems && options.gridMenu.customItems.filter((item: CustomGridMenu) => item.command === 'toggle-filter').length === 0) {\r\n        options.gridMenu.customItems.push(\r\n          {\r\n            iconCssClass: 'fa fa-random',\r\n            title: options.enableTranslate ? this.translate.instant('TOGGLE_FILTER_ROW') : 'Toggle Filter Row',\r\n            disabled: false,\r\n            command: 'toggle-filter',\r\n            positionOrder: 51\r\n          }\r\n        );\r\n      }\r\n\r\n      // show grid menu: refresh dataset\r\n      if (options && options.gridMenu && options.gridMenu.showRefreshDatasetCommand && backendApi && options.gridMenu.customItems && options.gridMenu.customItems.filter((item: CustomGridMenu) => item.command === 'refresh-dataset').length === 0) {\r\n        options.gridMenu.customItems.push(\r\n          {\r\n            iconCssClass: 'fa fa-refresh',\r\n            title: options.enableTranslate ? this.translate.instant('REFRESH_DATASET') : 'Refresh Dataset',\r\n            disabled: false,\r\n            command: 'refresh-dataset',\r\n            positionOrder: 54\r\n          }\r\n        );\r\n      }\r\n\r\n    }\r\n\r\n    // show grid menu: export to file\r\n    if (options && options.enableExport && options.gridMenu && options.gridMenu.showExportCsvCommand && options.gridMenu.customItems && options.gridMenu.customItems.filter((item: CustomGridMenu) => item.command === 'export-csv').length === 0) {\r\n      options.gridMenu.customItems.push(\r\n        {\r\n          iconCssClass: 'fa fa-download',\r\n          title: options.enableTranslate ? this.translate.instant('EXPORT_TO_CSV') : 'Export in CSV format',\r\n          disabled: false,\r\n          command: 'export-csv',\r\n          positionOrder: 52\r\n        }\r\n      );\r\n    }\r\n    // show grid menu: export to text file as tab delimited\r\n    if (options && options.enableExport && options.gridMenu && options.gridMenu.showExportTextDelimitedCommand && options.gridMenu.customItems && options.gridMenu.customItems.filter((item: CustomGridMenu) => item.command === 'export-text-delimited').length === 0) {\r\n      options.gridMenu.customItems.push(\r\n        {\r\n          iconCssClass: 'fa fa-download',\r\n          title: options.enableTranslate ? this.translate.instant('EXPORT_TO_TAB_DELIMITED') : 'Export in Text format (Tab delimited)',\r\n          disabled: false,\r\n          command: 'export-text-delimited',\r\n          positionOrder: 53\r\n        }\r\n      );\r\n    }\r\n\r\n    // Command callback, what will be executed after command is clicked\r\n    if (options.gridMenu && options.gridMenu.customItems.length > 0) {\r\n      options.gridMenu.onCommand = (e, args) => {\r\n        if (args && args.command) {\r\n          switch (args.command) {\r\n            case 'clear-filter':\r\n              this.filterService.clearFilters();\r\n              this._dataView.refresh();\r\n              break;\r\n            case 'export-csv':\r\n              this.exportService.exportToFile({\r\n                delimiter: DelimiterType.comma,\r\n                filename: 'export',\r\n                format: FileType.csv,\r\n                useUtf8WithBom: true\r\n              });\r\n              break;\r\n            case 'export-text-delimited':\r\n              this.exportService.exportToFile({\r\n                delimiter: DelimiterType.tab,\r\n                filename: 'export',\r\n                format: FileType.txt,\r\n                useUtf8WithBom: true\r\n              });\r\n              break;\r\n            case 'toggle-filter':\r\n              grid.setHeaderRowVisibility(!grid.getOptions().showHeaderRow);\r\n              break;\r\n            case 'toggle-toppanel':\r\n              grid.setTopPanelVisibility(!grid.getOptions().showTopPanel);\r\n              break;\r\n            case 'clear-filter':\r\n              this.filterService.clearFilters();\r\n              this._dataView.refresh();\r\n              break;\r\n            case 'refresh-dataset':\r\n              this.refreshBackendDataset(options);\r\n              break;\r\n            default:\r\n              alert('Command: ' + args.command);\r\n              break;\r\n          }\r\n        }\r\n      };\r\n    }\r\n\r\n\r\n\r\n    // add the custom \"Commands\" title if there are any commands\r\n    if (options && options.gridMenu && options.gridMenu.customItems && options.gridMenu.customItems.length > 0) {\r\n      const customTitle = options.enableTranslate ? this.translate.instant('COMMANDS') : 'Commands';\r\n      options.gridMenu.customTitle = options.gridMenu.customTitle || customTitle;\r\n\r\n      // sort the custom items by their position in the list\r\n      options.gridMenu.customItems.sort((itemA, itemB) => {\r\n        if (itemA && itemB && itemA.hasOwnProperty('positionOrder') && itemB.hasOwnProperty('positionOrder')) {\r\n          return itemA.positionOrder - itemB.positionOrder;\r\n        }\r\n        return 0;\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @return default Grid Menu options\r\n   */\r\n  private getDefaultGridMenuOptions(): GridMenu {\r\n    return {\r\n      columnTitle: this.translate.instant('COLUMNS') || 'Columns',\r\n      forceFitTitle: this.translate.instant('FORCE_FIT_COLUMNS') || 'Force fit columns',\r\n      syncResizeTitle: this.translate.instant('SYNCHRONOUS_RESIZE') || 'Synchronous resize',\r\n      iconCssClass: 'fa fa-bars',\r\n      menuWidth: 18,\r\n      customTitle: undefined,\r\n      customItems: [],\r\n      showClearAllFiltersCommand: true,\r\n      showRefreshDatasetCommand: true,\r\n      showToggleFilterCommand: true\r\n    };\r\n  }\r\n\r\n  private refreshBackendDataset(gridOptions) {\r\n    let query;\r\n    const backendApi = gridOptions.backendServiceApi || gridOptions.onBackendEventApi;\r\n    if (!backendApi || !backendApi.service || !backendApi.process) {\r\n      throw new Error(`BackendServiceApi requires at least a \"process\" function and a \"service\" defined`);\r\n    }\r\n\r\n    if (backendApi.service) {\r\n      query = backendApi.service.buildQuery();\r\n    }\r\n\r\n    if (query && query !== '') {\r\n      if (backendApi.preProcess) {\r\n        backendApi.preProcess();\r\n      }\r\n\r\n      // the process could be an Observable (like HttpClient) or a Promise\r\n      // in any case, we need to have a Promise so that we can await on it (if an Observable, convert it to Promise)\r\n      const observableOrPromise = backendApi.process(query);\r\n\r\n      castToPromise(observableOrPromise).then((processResult: GraphqlResult | any) => {\r\n        // from the result, call our internal post process to update the Dataset and Pagination info\r\n        if (processResult && backendApi.internalPostProcess) {\r\n          backendApi.internalPostProcess(processResult);\r\n        }\r\n\r\n        // send the response process to the postProcess callback\r\n        if (backendApi.postProcess) {\r\n          backendApi.postProcess(processResult);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset all the Grid Menu options which have text to translate\r\n   * @param grid menu object\r\n   */\r\n  private resetGridMenuTranslations(gridMenu: GridMenu): GridMenu {\r\n    // we will reset the custom items array since the commands title have to be translated too (no worries, we will re-create it later)\r\n    gridMenu.customItems = [];\r\n    delete gridMenu.customTitle;\r\n\r\n    gridMenu.columnTitle = this.translate.instant('COLUMNS') || 'Columns';\r\n    gridMenu.forceFitTitle = this.translate.instant('FORCE_FIT_COLUMNS') || 'Force fit columns';\r\n    gridMenu.syncResizeTitle = this.translate.instant('SYNCHRONOUS_RESIZE') || 'Synchronous resize';\r\n\r\n    return gridMenu;\r\n  }\r\n\r\n  /**\r\n   * Translate the Column Picker and it's last 2 checkboxes\r\n   * Note that the only way that seems to work is to destroy and re-create the Column Picker\r\n   * Changing only the columnPicker.columnTitle with i18n translate was not enough.\r\n   */\r\n  translateColumnPicker() {\r\n    // destroy and re-create the Column Picker which seems to be the only way to translate properly\r\n    if (this.columnPickerControl) {\r\n      this.columnPickerControl.destroy();\r\n      this.columnPickerControl = null;\r\n    }\r\n\r\n    this._gridOptions.columnPicker = undefined;\r\n    this.createColumnPicker(this._grid, this.visibleColumns, this._gridOptions);\r\n  }\r\n\r\n  /**\r\n   * Translate the Grid Menu ColumnTitle and CustomTitle.\r\n   * Note that the only way that seems to work is to destroy and re-create the Grid Menu\r\n   * Changing only the gridMenu.columnTitle with i18n translate was not enough.\r\n   */\r\n  translateGridMenu() {\r\n    // destroy and re-create the Grid Menu which seems to be the only way to translate properly\r\n    this.gridMenuControl.destroy();\r\n\r\n    // reset all Grid Menu options that have translation text & then re-create the Grid Menu and also the custom items array\r\n    if (this._gridOptions && this._gridOptions.gridMenu) {\r\n      this._gridOptions.gridMenu = this.resetGridMenuTranslations(this._gridOptions.gridMenu);\r\n    }\r\n    this.createGridMenu(this._grid, this.visibleColumns, this._gridOptions);\r\n  }\r\n\r\n  /**\r\n   * Translate manually the header titles.\r\n   * We could optionally pass a locale (that will change currently loaded locale), else it will use current locale\r\n   * @param locale locale to use\r\n   */\r\n  translateHeaders(locale?: string) {\r\n    if (locale) {\r\n      this.translate.use(locale);\r\n    }\r\n\r\n    for (const column of this._columnDefinitions) {\r\n      if (column.headerKey) {\r\n        column.name = this.translate.instant(column.headerKey);\r\n      }\r\n    }\r\n\r\n    // calling setColumns() will trigger a grid re-render\r\n    this._grid.setColumns(this._columnDefinitions);\r\n  }\r\n\r\n  /**\r\n   * Attach/Create different plugins before the Grid creation.\r\n   * For example the multi-select have to be added to the column definition before the grid is created to work properly\r\n   * @param columnDefinitions\r\n   * @param options\r\n   */\r\n  createPluginBeforeGridCreation(columnDefinitions: Column[], options: GridOption) {\r\n    if (options.enableCheckboxSelector) {\r\n      this.checkboxSelectorPlugin = new Slick.CheckboxSelectColumn(options.checkboxSelector || {});\r\n      const selectionColumn: Column = this.checkboxSelectorPlugin.getColumnDefinition();\r\n      selectionColumn.excludeFromExport = true;\r\n      selectionColumn.excludeFromQuery = true;\r\n      columnDefinitions.unshift(selectionColumn);\r\n    }\r\n  }\r\n}\r\n",
    "import { EventEmitter, Injectable } from '@angular/core';\r\nimport { TranslateService } from '@ngx-translate/core';\r\nimport { castToPromise } from './utilities';\r\nimport { FilterConditions } from './../filter-conditions';\r\nimport { Filters } from './../filters';\r\nimport {\r\n  Column,\r\n  ColumnFilters,\r\n  Filter,\r\n  FilterArguments,\r\n  FieldType,\r\n  FilterType,\r\n  GridOption,\r\n  OperatorType,\r\n  CurrentFilter,\r\n  SearchTerm,\r\n  SlickEvent,\r\n  OperatorString\r\n} from './../models/index';\r\n\r\n// using external non-typed js libraries\r\ndeclare var Slick: any;\r\n\r\n@Injectable()\r\nexport class FilterService {\r\n  private _eventHandler = new Slick.EventHandler();\r\n  private _subscriber: SlickEvent = new Slick.Event();\r\n  private _filters: any[] = [];\r\n  private _columnFilters: ColumnFilters = {};\r\n  private _dataView: any;\r\n  private _grid: any;\r\n  private _gridOptions: GridOption;\r\n  private _onFilterChangedOptions: any;\r\n  onFilterChanged = new EventEmitter<string>();\r\n\r\n  constructor(private translate: TranslateService) { }\r\n\r\n  init(grid: any, gridOptions: GridOption, columnDefinitions: Column[]): void {\r\n    this._grid = grid;\r\n    this._gridOptions = gridOptions;\r\n  }\r\n\r\n  /**\r\n   * Attach a backend filter hook to the grid\r\n   * @param grid SlickGrid Grid object\r\n   * @param gridOptions Grid Options object\r\n   */\r\n  attachBackendOnFilter(grid: any, options: GridOption) {\r\n    this._filters = [];\r\n    this.emitFilterChangedBy('remote');\r\n\r\n    this._subscriber = new Slick.Event();\r\n    this._subscriber.subscribe(this.attachBackendOnFilterSubscribe);\r\n\r\n    // subscribe to SlickGrid onHeaderRowCellRendered event to create filter template\r\n    this._eventHandler.subscribe(grid.onHeaderRowCellRendered, (e: Event, args: any) => {\r\n      this.addFilterTemplateToHeaderRow(args);\r\n    });\r\n  }\r\n\r\n  async attachBackendOnFilterSubscribe(event: Event, args: any) {\r\n    if (!args || !args.grid) {\r\n      throw new Error('Something went wrong when trying to attach the \"attachBackendOnFilterSubscribe(event, args)\" function, it seems that \"args\" is not populated correctly');\r\n    }\r\n    const gridOptions: GridOption = args.grid.getOptions() || {};\r\n\r\n    const backendApi = gridOptions.backendServiceApi || gridOptions.onBackendEventApi;\r\n    if (!backendApi || !backendApi.process || !backendApi.service) {\r\n      throw new Error(`BackendServiceApi requires at least a \"process\" function and a \"service\" defined`);\r\n    }\r\n\r\n    // run a preProcess callback if defined\r\n    if (backendApi.preProcess) {\r\n      backendApi.preProcess();\r\n    }\r\n\r\n    // call the service to get a query back\r\n    const query = await backendApi.service.onFilterChanged(event, args);\r\n\r\n    // the process could be an Observable (like HttpClient) or a Promise\r\n    // in any case, we need to have a Promise so that we can await on it (if an Observable, convert it to Promise)\r\n    const observableOrPromise = backendApi.process(query);\r\n    const processResult = await castToPromise(observableOrPromise);\r\n\r\n    // from the result, call our internal post process to update the Dataset and Pagination info\r\n    if (processResult && backendApi.internalPostProcess) {\r\n      backendApi.internalPostProcess(processResult);\r\n    }\r\n\r\n    // send the response process to the postProcess callback\r\n    if (backendApi.postProcess !== undefined) {\r\n      backendApi.postProcess(processResult);\r\n    }\r\n  }\r\n\r\n  /** Clear the search filters (below the column titles) */\r\n  clearFilters() {\r\n    this._filters.forEach((filter, index) => {\r\n      if (filter && filter.clear) {\r\n        // clear element and trigger a change\r\n        filter.clear(true);\r\n      }\r\n    });\r\n\r\n    // we need to loop through all columnFilters and delete them 1 by 1\r\n    // only trying to clear columnFilter (without looping through) would not trigger a dataset change\r\n    for (const columnId in this._columnFilters) {\r\n      if (columnId && this._columnFilters[columnId]) {\r\n        delete this._columnFilters[columnId];\r\n      }\r\n    }\r\n\r\n    // we also need to refresh the dataView and optionally the grid (it's optional since we use DataView)\r\n    if (this._dataView) {\r\n      this._dataView.refresh();\r\n      this._grid.invalidate();\r\n      this._grid.render();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attach a local filter hook to the grid\r\n   * @param grid SlickGrid Grid object\r\n   * @param gridOptions Grid Options object\r\n   * @param dataView\r\n   */\r\n  attachLocalOnFilter(grid: any, options: GridOption, dataView: any) {\r\n    this._dataView = dataView;\r\n    this._filters = [];\r\n    this.emitFilterChangedBy('local');\r\n\r\n    dataView.setFilterArgs({ columnFilters: this._columnFilters, grid: this._grid });\r\n    dataView.setFilter(this.customLocalFilter.bind(this, dataView));\r\n\r\n    this._subscriber = new Slick.Event();\r\n    this._subscriber.subscribe((e: any, args: any) => {\r\n      const columnId = args.columnId;\r\n      if (columnId != null) {\r\n        dataView.refresh();\r\n      }\r\n    });\r\n\r\n    // subscribe to SlickGrid onHeaderRowCellRendered event to create filter template\r\n    this._eventHandler.subscribe(grid.onHeaderRowCellRendered, (e: Event, args: any) => {\r\n      this.addFilterTemplateToHeaderRow(args);\r\n    });\r\n  }\r\n\r\n  customLocalFilter(dataView: any, item: any, args: any) {\r\n    for (const columnId of Object.keys(args.columnFilters)) {\r\n      const columnFilter = args.columnFilters[columnId];\r\n      const columnIndex = args.grid.getColumnIndex(columnId);\r\n      const columnDef = args.grid.getColumns()[columnIndex];\r\n      if (!columnDef) {\r\n        return false;\r\n      }\r\n      const fieldType = columnDef.type || FieldType.string;\r\n      const filterSearchType = (columnDef.filterSearchType) ? columnDef.filterSearchType : null;\r\n\r\n      let cellValue = item[columnDef.queryField || columnDef.field];\r\n      const searchTerms = (columnFilter && columnFilter.searchTerms) ? columnFilter.searchTerms : null;\r\n      let fieldSearchValue = (columnFilter && (columnFilter.searchTerm !== undefined || columnFilter.searchTerm !== null)) ? columnFilter.searchTerm : undefined;\r\n\r\n      if (typeof fieldSearchValue === 'undefined') {\r\n        fieldSearchValue = '';\r\n      }\r\n      fieldSearchValue = '' + fieldSearchValue; // make sure it's a string\r\n\r\n      const matches = fieldSearchValue.match(/^([<>!=\\*]{0,2})(.*[^<>!=\\*])([\\*]?)$/); // group 1: Operator, 2: searchValue, 3: last char is '*' (meaning starts with, ex.: abc*)\r\n      let operator = columnFilter.operator || ((matches) ? matches[1] : '');\r\n      const searchTerm = (!!matches) ? matches[2] : '';\r\n      const lastValueChar = (!!matches) ? matches[3] : '';\r\n\r\n      // when using a Filter that is not a custom type, we want to make sure that we have a default operator type\r\n      // for example a multiple-select should always be using IN, while a single select will use an EQ\r\n      const filterType = (columnDef.filter && columnDef.filter.type) ? columnDef.filter.type : FilterType.input;\r\n      if (!operator && filterType !== FilterType.custom) {\r\n        switch (filterType) {\r\n          case FilterType.select:\r\n          case FilterType.multipleSelect:\r\n            operator = 'IN';\r\n            break;\r\n          case FilterType.singleSelect:\r\n            operator = 'EQ';\r\n            break;\r\n          default:\r\n            operator = operator;\r\n            break;\r\n        }\r\n      }\r\n\r\n      // no need to query if search value is empty\r\n      if (searchTerm === '' && !searchTerms) {\r\n        return true;\r\n      }\r\n\r\n      // filter search terms should always be string type (even though we permit the end user to input numbers)\r\n      // so make sure each term are strings, if user has some default search terms, we will cast them to string\r\n      if (searchTerms && Array.isArray(searchTerms)) {\r\n        for (let k = 0, ln = searchTerms.length; k < ln; k++) {\r\n          // make sure all search terms are strings\r\n          searchTerms[k] = ((searchTerms[k] === undefined || searchTerms[k] === null) ? '' : searchTerms[k]) + '';\r\n        }\r\n      }\r\n\r\n      // when using localization (i18n), we should use the formatter output to search as the new cell value\r\n      if (columnDef && columnDef.params && columnDef.params.useFormatterOuputToFilter) {\r\n        const rowIndex = (dataView && typeof dataView.getIdxById === 'function') ? dataView.getIdxById(item.id) : 0;\r\n        cellValue = columnDef.formatter(rowIndex, columnIndex, cellValue, columnDef, item, this._grid);\r\n      }\r\n\r\n      // make sure cell value is always a string\r\n      if (typeof cellValue === 'number') {\r\n        cellValue = cellValue.toString();\r\n      }\r\n\r\n      const conditionOptions = {\r\n        fieldType,\r\n        searchTerms,\r\n        searchTerm,\r\n        cellValue,\r\n        operator,\r\n        cellValueLastChar: lastValueChar,\r\n        filterSearchType\r\n      };\r\n\r\n      if (!FilterConditions.executeMappedCondition(conditionOptions)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  dispose() {\r\n    this.disposeColumnFilters();\r\n\r\n    // unsubscribe all SlickGrid events\r\n    this._eventHandler.unsubscribeAll();\r\n\r\n    // unsubscribe local event\r\n    if (this._subscriber && typeof this._subscriber.unsubscribe === 'function') {\r\n      this._subscriber.unsubscribe();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dispose of the filters, since it's a singleton, we don't want to affect other grids with same columns\r\n   */\r\n  disposeColumnFilters() {\r\n    // we need to loop through all columnFilters and delete them 1 by 1\r\n    // only trying to make columnFilter an empty (without looping) would not trigger a dataset change\r\n    for (const columnId in this._columnFilters) {\r\n      if (columnId && this._columnFilters[columnId]) {\r\n        delete this._columnFilters[columnId];\r\n      }\r\n    }\r\n\r\n    // also destroy each Filter instances\r\n    this._filters.forEach((filter, index) => {\r\n      if (filter && filter.destroy) {\r\n        filter.destroy(true);\r\n      }\r\n    });\r\n  }\r\n\r\n  getColumnFilters() {\r\n    return this._columnFilters;\r\n  }\r\n\r\n  getCurrentLocalFilters(): CurrentFilter[] {\r\n    const currentFilters: CurrentFilter[] = [];\r\n    if (this._columnFilters) {\r\n      for (const colId of Object.keys(this._columnFilters)) {\r\n        const columnFilter = this._columnFilters[colId];\r\n        const filter = { columnId: colId || '' } as CurrentFilter;\r\n        if (columnFilter && columnFilter.searchTerms) {\r\n          filter.searchTerms = columnFilter.searchTerms;\r\n        } else {\r\n          filter.searchTerm = (columnFilter && (columnFilter.searchTerm !== undefined || columnFilter.searchTerm !== null)) ? columnFilter.searchTerm : undefined;\r\n        }\r\n        currentFilters.push(filter);\r\n      }\r\n    }\r\n    return currentFilters;\r\n  }\r\n\r\n  callbackSearchEvent(e: Event | undefined, args: { columnDef: Column, operator?: OperatorType | OperatorString, searchTerms?: string[] | number[] }) {\r\n    const targetValue = (e && e.target) ? (e.target as HTMLInputElement).value : undefined;\r\n    const searchTerms = (args && args.searchTerms && Array.isArray(args.searchTerms)) ? args.searchTerms : [];\r\n    const columnId = (args && args.columnDef) ? args.columnDef.id || '' : '';\r\n\r\n    if (!targetValue && searchTerms.length === 0) {\r\n      // delete the property from the columnFilters when it becomes empty\r\n      // without doing this, it would leave an incorrect state of the previous column filters when filtering on another column\r\n      delete this._columnFilters[columnId];\r\n    } else {\r\n      const colId = '' + columnId as string;\r\n      this._columnFilters[colId] = {\r\n        columnId: colId,\r\n        columnDef: args.columnDef || null,\r\n        operator: args.operator || undefined,\r\n        searchTerms: args.searchTerms || undefined,\r\n        searchTerm: ((e && e.target) ? (e.target as HTMLInputElement).value : undefined),\r\n      };\r\n    }\r\n\r\n    this.triggerEvent(this._subscriber, {\r\n      columnId,\r\n      columnDef: args.columnDef || null,\r\n      columnFilters: this._columnFilters,\r\n      searchTerms: args.searchTerms || undefined,\r\n      searchTerm: ((e && e.target) ? (e.target as HTMLInputElement).value : undefined),\r\n      serviceOptions: this._onFilterChangedOptions,\r\n      grid: this._grid\r\n    }, e);\r\n  }\r\n\r\n  addFilterTemplateToHeaderRow(args: { column: Column; grid: any; node: any }) {\r\n    const columnDef = args.column;\r\n    const columnId = columnDef.id || '';\r\n\r\n    if (columnDef && columnId !== 'selector' && columnDef.filterable) {\r\n      let searchTerms: SearchTerm[] | undefined;\r\n      let searchTerm: SearchTerm | undefined;\r\n\r\n      if (this._columnFilters[columnDef.id]) {\r\n        searchTerm = this._columnFilters[columnDef.id].searchTerm || undefined;\r\n        searchTerms = this._columnFilters[columnDef.id].searchTerms || undefined;\r\n      } else if (columnDef.filter) {\r\n        // when hiding/showing (with Column Picker or Grid Menu), it will try to re-create yet again the filters (since SlickGrid does a re-render)\r\n        // because of that we need to first get searchTerm(s) from the columnFilters (that is what the user last entered)\r\n        searchTerms = columnDef.filter.searchTerms || undefined;\r\n        searchTerm = columnDef.filter.searchTerm || undefined;\r\n        this.updateColumnFilters(searchTerm, searchTerms, columnDef);\r\n      }\r\n\r\n      const filterArguments: FilterArguments = {\r\n        grid: this._grid,\r\n        searchTerm,\r\n        searchTerms,\r\n        columnDef,\r\n        callback: this.callbackSearchEvent.bind(this)\r\n      };\r\n\r\n      // depending on the Filter type, we will watch the correct event\r\n      const filterType = (columnDef.filter && columnDef.filter.type) ? columnDef.filter.type : FilterType.input;\r\n\r\n      let filter: Filter;\r\n      switch (filterType) {\r\n        case FilterType.custom:\r\n          if (columnDef && columnDef.filter && columnDef.filter.customFilter) {\r\n            filter = columnDef.filter.customFilter;\r\n          }\r\n          break;\r\n        case FilterType.select:\r\n          filter = new Filters.select(this.translate);\r\n          break;\r\n        case FilterType.multipleSelect:\r\n          filter = new Filters.multipleSelect(this.translate);\r\n          break;\r\n        case FilterType.singleSelect:\r\n          filter = new Filters.singleSelect(this.translate);\r\n          break;\r\n        case FilterType.input:\r\n        default:\r\n          filter = new Filters.input();\r\n          break;\r\n      }\r\n\r\n      if (filter) {\r\n        filter.init(filterArguments);\r\n        const filterExistIndex = this._filters.findIndex((filt) => filter.columnDef.name === filt.columnDef.name);\r\n\r\n        // add to the filters arrays or replace it when found\r\n        if (filterExistIndex === -1) {\r\n          this._filters.push(filter);\r\n        } else {\r\n          this._filters[filterExistIndex] = filter;\r\n        }\r\n\r\n        // when hiding/showing (with Column Picker or Grid Menu), it will try to re-create yet again the filters (since SlickGrid does a re-render)\r\n        // we need to also set again the values in the DOM elements if the values were set by a searchTerm(s)\r\n        if ((searchTerm || searchTerms) && filter.setValues) {\r\n          filter.setValues(searchTerm || searchTerms);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * A simple function that is attached to the subscriber and emit a change when the sort is called.\r\n   * Other services, like Pagination, can then subscribe to it.\r\n   * @param sender\r\n   */\r\n  emitFilterChangedBy(sender: string) {\r\n    this._subscriber.subscribe(() => this.onFilterChanged.emit(`onFilterChanged by ${sender}`));\r\n  }\r\n\r\n  /**\r\n   * When user passes an array of preset filters, we need to pre-polulate each column filter searchTerm(s)\r\n   * The process is to loop through the preset filters array, find the associated column from columnDefinitions and fill in the filter object searchTerm(s)\r\n   * This is basically the same as if we would manually add searchTerm(s) to a column filter object in the column definition, but we do it programmatically.\r\n   * At the end of the day, when creating the Filter (DOM Element), it will use these searchTerm(s) so we can take advantage of that without recoding each Filter type (DOM element)\r\n   * @param gridOptions\r\n   * @param columnDefinitions\r\n   */\r\n  populateColumnFilterSearchTerms(gridOptions: GridOption, columnDefinitions: Column[]) {\r\n    if (gridOptions.presets && gridOptions.presets.filters) {\r\n      const filters = gridOptions.presets.filters;\r\n      columnDefinitions.forEach((columnDef: Column) =>  {\r\n        const columnPreset = filters.find((presetFilter: CurrentFilter) => {\r\n          return presetFilter.columnId === columnDef.id;\r\n        });\r\n        if (columnPreset && columnPreset.searchTerm) {\r\n          columnDef.filter = columnDef.filter || {};\r\n          columnDef.filter.searchTerm = columnPreset.searchTerm;\r\n        }\r\n        if (columnPreset && columnPreset.searchTerms) {\r\n          columnDef.filter = columnDef.filter || {};\r\n          columnDef.filter.operator = columnDef.filter.operator || OperatorType.in;\r\n          columnDef.filter.searchTerms = columnPreset.searchTerms;\r\n        }\r\n      });\r\n    }\r\n    return columnDefinitions;\r\n  }\r\n\r\n  private updateColumnFilters(searchTerm: SearchTerm | undefined, searchTerms: SearchTerm[] | undefined, columnDef: any) {\r\n    if (searchTerm !== undefined && searchTerm !== null && searchTerm !== '') {\r\n      this._columnFilters[columnDef.id] = {\r\n        columnId: columnDef.id,\r\n        columnDef,\r\n        searchTerm,\r\n        operator: (columnDef && columnDef.filter && columnDef.filter.operator) ? columnDef.filter.operator : null,\r\n        type: (columnDef && columnDef.filter && columnDef.filter.type) ? columnDef.filter.type : FilterType.input\r\n      };\r\n    }\r\n    if (searchTerms) {\r\n      // this._columnFilters.searchTerms = searchTerms;\r\n      this._columnFilters[columnDef.id] = {\r\n        columnId: columnDef.id,\r\n        columnDef,\r\n        searchTerms,\r\n        operator: (columnDef && columnDef.filter && columnDef.filter.operator) ? columnDef.filter.operator : null,\r\n        type: (columnDef && columnDef.filter && columnDef.filter.type) ? columnDef.filter.type : FilterType.input\r\n      };\r\n    }\r\n  }\r\n\r\n  private triggerEvent(evt: any, args: any, e: any) {\r\n    e = e || new Slick.EventData();\r\n    return evt.notify(args, e, args.grid);\r\n  }\r\n}\r\n",
    "/**\r\n * This GraphqlQueryBuilder class is a lib that already exist\r\n * but was causing issues with TypeScript, RequireJS and other bundler/packagers\r\n * and so I rewrote it in pure TypeScript.\r\n *\r\n * The previous lib can be viewed here at this Github\r\n * https://github.com/codemeasandwich/graphql-query-builder\r\n */\r\nexport default class GraphqlQueryBuilder {\r\n  alias: string;\r\n  head: any[] = [];\r\n  body: any;\r\n\r\n  /* Constructor, query/mutator you wish to use, and an alias or filter arguments. */\r\n  constructor(private queryFnName: string, aliasOrFilter?: string | object) {\r\n    if (typeof aliasOrFilter === 'function') {\r\n      this.alias = aliasOrFilter;\r\n    } else if (typeof aliasOrFilter === 'object') {\r\n      this.filter(aliasOrFilter);\r\n    } else if (undefined === aliasOrFilter && 2 === arguments.length) {\r\n      throw new TypeError(`You have passed undefined as Second argument to \"Query\"`);\r\n    } else if (undefined !== aliasOrFilter) {\r\n      throw new TypeError(`Second argument to \"Query\" should be an alias name(String) or filter arguments(Object). was passed ${aliasOrFilter}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The parameters to run the query against.\r\n   * @param filters An object mapping attribute to values\r\n   */\r\n  filter(filters: any) {\r\n    for (const prop of Object.keys(filters)) {\r\n      if (typeof filters[prop] === 'function') {\r\n        continue;\r\n      }\r\n      const val = this.getGraphQLValue(filters[prop]);\r\n      if (val === '{}') {\r\n        continue;\r\n      }\r\n      this.head.push(`${prop}:${val}`);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Outlines the properties you wish to be returned from the query.\r\n   * @param properties representing each attribute you want Returned\r\n   */\r\n  find(...searches: any[]) { // THIS NEED TO BE A \"FUNCTION\" to scope 'arguments'\r\n    if (!searches) {\r\n      throw new TypeError(`find value can not be >>falsy<<`);\r\n    }\r\n    // if its a string.. it may have other values\r\n    // else it sould be an Object or Array of maped values\r\n    const searchKeys = (searches.length === 1 && Array.isArray(searches[0])) ? searches[0] : searches;\r\n    this.body = this.parceFind(searchKeys);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * set an alias for this result.\r\n   * @param alias\r\n   */\r\n  setAlias(alias: string) {\r\n    this.alias = alias;\r\n  }\r\n\r\n  /**\r\n   * Return to the formatted query string\r\n   * @return\r\n   */\r\n  toString() {\r\n    if (this.body === undefined) {\r\n      throw new ReferenceError(`return properties are not defined. use the 'find' function to defined them`);\r\n    }\r\n\r\n    return `${(this.alias) ? (this.alias + ':') : ''} ${this.queryFnName} ${(this.head.length > 0) ? '(' + this.head.join(',') + ')' : ''}  { ${this.body} }`;\r\n  }\r\n\r\n  // --\r\n  // PRIVATE FUNCTIONS\r\n  // -----------------\r\n\r\n  private parceFind(_levelA: any[]) {\r\n    const propsA = _levelA.map((currentValue, index) => {\r\n      const itemX = _levelA[index];\r\n\r\n      if (itemX instanceof GraphqlQueryBuilder) {\r\n        return itemX.toString();\r\n      } else if (!Array.isArray(itemX) && typeof itemX === 'object') {\r\n        const propsAA = Object.keys(itemX);\r\n        if (1 !== propsAA.length) {\r\n          throw new RangeError(`Alias objects should only have one value. was passed: ${JSON.stringify(itemX)}`);\r\n        }\r\n        const propS = propsAA[0];\r\n        const item = itemX[propS];\r\n\r\n        if (Array.isArray(item)) {\r\n          return new GraphqlQueryBuilder(propS).find(item);\r\n        }\r\n        return `${propS} : ${item} `;\r\n      } else if (typeof itemX === 'string') {\r\n        return itemX;\r\n      } else {\r\n        throw new RangeError(`cannot handle Find value of ${itemX}`);\r\n      }\r\n    });\r\n\r\n    return propsA.join(',');\r\n  }\r\n\r\n  private getGraphQLValue(value: any) {\r\n    if (typeof value === 'string') {\r\n      value = JSON.stringify(value);\r\n    } else if (Array.isArray(value)) {\r\n      value = value.map(item => {\r\n        return this.getGraphQLValue(item);\r\n      }).join();\r\n      value = `[${value}]`;\r\n    } else if (value instanceof Date) {\r\n      value = JSON.stringify(value);\r\n    } else if (value !== null && typeof value === 'object') {\r\n      value = this.objectToString(value);\r\n    }\r\n    return value;\r\n  }\r\n\r\n  private objectToString(obj: any) {\r\n    const sourceA = [];\r\n\r\n    for (const prop of Object.keys(obj)) {\r\n      if (typeof obj[prop] === 'function') {\r\n        continue;\r\n      }\r\n      sourceA.push(`${prop}:${this.getGraphQLValue(obj[prop])}`);\r\n    }\r\n    return `{${sourceA.join()}}`;\r\n  }\r\n}\r\n",
    "import { Injectable } from '@angular/core';\r\nimport { TranslateService } from '@ngx-translate/core';\r\nimport { mapOperatorType, mapOperatorByFilterType } from './utilities';\r\nimport {\r\n  BackendService,\r\n  Column,\r\n  ColumnFilter,\r\n  ColumnFilters,\r\n  CurrentFilter,\r\n  CurrentPagination,\r\n  CurrentSorter,\r\n  FilterChangedArgs,\r\n  GraphqlCursorPaginationOption,\r\n  GraphqlDatasetFilter,\r\n  GraphqlFilteringOption,\r\n  GraphqlPaginationOption,\r\n  GraphqlServiceOption,\r\n  GraphqlSortingOption,\r\n  GridOption,\r\n  Pagination,\r\n  PaginationChangedArgs,\r\n  SortChanged,\r\n  SortChangedArgs,\r\n  SortDirection,\r\n  SortDirectionString\r\n} from './../models/index';\r\nimport QueryBuilder from './graphqlQueryBuilder';\r\n\r\n// timer for keeping track of user typing waits\r\nlet timer: any;\r\nconst DEFAULT_FILTER_TYPING_DEBOUNCE = 750;\r\nconst DEFAULT_ITEMS_PER_PAGE = 25;\r\nconst DEFAULT_PAGE_SIZE = 20;\r\n\r\n@Injectable()\r\nexport class GraphqlService implements BackendService {\r\n  private _currentFilters: ColumnFilters | CurrentFilter[];\r\n  private _currentPagination: CurrentPagination;\r\n  private _currentSorters: CurrentSorter[];\r\n  private _columnDefinitions: Column[];\r\n  private _gridOptions: GridOption;\r\n  private _grid: any;\r\n  options: GraphqlServiceOption;\r\n  pagination: Pagination | undefined;\r\n  defaultOrderBy: GraphqlSortingOption = { field: 'id', direction: SortDirection.ASC };\r\n  defaultPaginationOptions: GraphqlPaginationOption | GraphqlCursorPaginationOption = {\r\n    first: DEFAULT_ITEMS_PER_PAGE,\r\n    offset: 0\r\n  };\r\n\r\n  constructor(private translate: TranslateService) {}\r\n\r\n  /**\r\n   * Build the GraphQL query, since the service include/exclude cursor, the output query will be different.\r\n   * @param serviceOptions GraphqlServiceOption\r\n   */\r\n  buildQuery() {\r\n    if (!this.options || !this.options.datasetName || (!this._columnDefinitions && !this.options.columnDefinitions)) {\r\n      throw new Error('GraphQL Service requires \"datasetName\" & \"columnDefinitions\" properties for it to work');\r\n    }\r\n\r\n    // get the column definitions and exclude some if they were tagged as excluded\r\n    let columnDefinitions = this._columnDefinitions || this.options.columnDefinitions;\r\n    columnDefinitions = columnDefinitions.filter((column: Column) => !column.excludeFromQuery);\r\n\r\n    const queryQb = new QueryBuilder('query');\r\n    const datasetQb = new QueryBuilder(this.options.datasetName);\r\n    const pageInfoQb = new QueryBuilder('pageInfo');\r\n    const dataQb = (this.options.isWithCursor) ? new QueryBuilder('edges') : new QueryBuilder('nodes');\r\n\r\n    // get all the columnds Ids for the filters to work\r\n    let columnIds: string[];\r\n    if (columnDefinitions) {\r\n      columnIds = Array.isArray(columnDefinitions) ? columnDefinitions.map((column) => column.field) : [];\r\n    } else {\r\n      columnIds = this.options.columnIds || [];\r\n    }\r\n\r\n    // Slickgrid also requires the \"id\" field to be part of DataView\r\n    // push it to the GraphQL query if it wasn't already part of the list\r\n    if (columnIds.indexOf('id') === -1) {\r\n      columnIds.push('id');\r\n    }\r\n\r\n    const filters = this.buildFilterQuery(columnIds);\r\n\r\n    if (this.options.isWithCursor) {\r\n      // ...pageInfo { hasNextPage, endCursor }, edges { cursor, node { _filters_ } }\r\n      pageInfoQb.find('hasNextPage', 'endCursor');\r\n      dataQb.find(['cursor', { node: filters }]);\r\n    } else {\r\n      // ...pageInfo { hasNextPage }, nodes { _filters_ }\r\n      pageInfoQb.find('hasNextPage');\r\n      dataQb.find(filters);\r\n    }\r\n\r\n    datasetQb.find(['totalCount', pageInfoQb, dataQb]);\r\n\r\n    // add dataset filters, could be Pagination and SortingFilters and/or FieldFilters\r\n    const datasetFilters: GraphqlDatasetFilter = {\r\n      ...this.options.paginationOptions,\r\n      first: ((this.options.paginationOptions && this.options.paginationOptions.first) ? this.options.paginationOptions.first : ((this.pagination && this.pagination.pageSize) ? this.pagination.pageSize : null)) || this.defaultPaginationOptions.first\r\n    };\r\n\r\n    if (!this.options.isWithCursor) {\r\n      datasetFilters.offset = ((this.options.paginationOptions && this.options.paginationOptions.hasOwnProperty('offset')) ? +this.options.paginationOptions['offset'] : 0);\r\n    }\r\n\r\n    if (this.options.sortingOptions && Array.isArray(this.options.sortingOptions) && this.options.sortingOptions.length > 0) {\r\n      // orderBy: [{ field:x, direction: 'ASC' }]\r\n      datasetFilters.orderBy = this.options.sortingOptions;\r\n    }\r\n    if (this.options.filteringOptions && Array.isArray(this.options.filteringOptions) && this.options.filteringOptions.length > 0) {\r\n      // filterBy: [{ field: date, operator: '>', value: '2000-10-10' }]\r\n      datasetFilters.filterBy = this.options.filteringOptions;\r\n    }\r\n    if (this.options.addLocaleIntoQuery) {\r\n      // first: 20, ... locale: \"en-CA\"\r\n      datasetFilters.locale = this.translate.currentLang || 'en';\r\n    }\r\n\r\n    // query { users(first: 20, orderBy: [], filterBy: [])}\r\n    datasetQb.filter(datasetFilters);\r\n    queryQb.find(datasetQb);\r\n\r\n    const enumSearchProperties = ['direction:', 'field:', 'operator:'];\r\n    return this.trimDoubleQuotesOnEnumField(queryQb.toString(), enumSearchProperties, this.options.keepArgumentFieldDoubleQuotes || false);\r\n  }\r\n\r\n  /**\r\n   * From an input array of strings, we want to build a GraphQL query string.\r\n   * The process has to take the dot notation and parse it into a valid GraphQL query\r\n   * Following this SO answer https://stackoverflow.com/a/47705476/1212166\r\n   *\r\n   * INPUT\r\n   *  ['firstName', 'lastName', 'billing.address.street', 'billing.address.zip']\r\n   * OUTPUT\r\n   * firstName, lastName, billing{address{street, zip}}\r\n   * @param inputArray\r\n   */\r\n  buildFilterQuery(inputArray: string[]) {\r\n\r\n    const set = (o: any = {}, a: any) => {\r\n      const k = a.shift();\r\n      o[k] = a.length ? set(o[k], a) : null;\r\n      return o;\r\n    };\r\n\r\n    const output = inputArray.reduce((o: any, a: string) => set(o, a.split('.')), {});\r\n\r\n    return JSON.stringify(output)\r\n      .replace(/\\\"|\\:|null/g, '')\r\n      .replace(/^\\{/, '')\r\n      .replace(/\\}$/, '');\r\n  }\r\n\r\n  init(serviceOptions?: GraphqlServiceOption, pagination?: Pagination, grid?: any): void {\r\n    this._grid = grid;\r\n    this.options = serviceOptions || {};\r\n    this.pagination = pagination;\r\n\r\n    if (grid && grid.getColumns && grid.getOptions) {\r\n      this._columnDefinitions = grid.getColumns();\r\n      this._gridOptions = grid.getOptions();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get an initialization of Pagination options\r\n   * @return Pagination Options\r\n   */\r\n  getInitPaginationOptions(): GraphqlDatasetFilter {\r\n    return (this.options.isWithCursor) ? { first: (this.pagination ? this.pagination.pageSize : DEFAULT_ITEMS_PER_PAGE) } : { first: (this.pagination ? this.pagination.pageSize : DEFAULT_ITEMS_PER_PAGE), offset: 0 };\r\n  }\r\n\r\n  /** Get the GraphQL dataset name */\r\n  getDatasetName(): string {\r\n    return this.options.datasetName || '';\r\n  }\r\n\r\n  /** Get the Filters that are currently used by the grid */\r\n  getCurrentFilters(): ColumnFilters | CurrentFilter[] {\r\n    return this._currentFilters;\r\n  }\r\n\r\n  /** Get the Pagination that is currently used by the grid */\r\n  getCurrentPagination(): CurrentPagination {\r\n    return this._currentPagination;\r\n  }\r\n\r\n  /** Get the Sorters that are currently used by the grid */\r\n  getCurrentSorters(): CurrentSorter[] {\r\n    return this._currentSorters;\r\n  }\r\n\r\n  /*\r\n   * Reset the pagination options\r\n   */\r\n  resetPaginationOptions() {\r\n    let paginationOptions;\r\n    if (this.options.isWithCursor) {\r\n      // first, last, after, before\r\n      paginationOptions = {\r\n        after: '',\r\n        before: undefined,\r\n        last: undefined\r\n      } as GraphqlCursorPaginationOption;\r\n    } else {\r\n      // first, last, offset\r\n      paginationOptions = (this.options.paginationOptions || this.getInitPaginationOptions()) as GraphqlPaginationOption;\r\n      paginationOptions.offset = 0;\r\n    }\r\n    this.updateOptions({ paginationOptions });\r\n  }\r\n\r\n  updateOptions(serviceOptions?: GraphqlServiceOption) {\r\n    this.options = { ...this.options, ...serviceOptions };\r\n  }\r\n\r\n  /*\r\n   * FILTERING\r\n   */\r\n  onFilterChanged(event: Event, args: FilterChangedArgs): Promise<string> {\r\n    const gridOptions: GridOption = this._gridOptions || args.grid.getOptions();\r\n    const backendApi = gridOptions.backendServiceApi || gridOptions.onBackendEventApi;\r\n\r\n    if (backendApi === undefined) {\r\n      throw new Error('Something went wrong in the GraphqlService, \"backendServiceApi\" is not initialized');\r\n    }\r\n\r\n    // only add a delay when user is typing, on select dropdown filter it will execute right away\r\n    let debounceTypingDelay = 0;\r\n    if (event && (event.type === 'keyup' || event.type === 'keydown')) {\r\n      debounceTypingDelay = backendApi.filterTypingDebounce || DEFAULT_FILTER_TYPING_DEBOUNCE;\r\n    }\r\n\r\n    const promise = new Promise<string>((resolve, reject) => {\r\n      if (!args || !args.grid) {\r\n        throw new Error('Something went wrong when trying create the GraphQL Backend Service, it seems that \"args\" is not populated correctly');\r\n      }\r\n\r\n      // loop through all columns to inspect filters & set the query\r\n      this.updateFilters(args.columnFilters, false);\r\n\r\n      // reset Pagination, then build the GraphQL query which we will use in the WebAPI callback\r\n      // wait a minimum user typing inactivity before processing any query\r\n      clearTimeout(timer);\r\n      timer = setTimeout(() => {\r\n        this.resetPaginationOptions();\r\n        resolve(this.buildQuery());\r\n      }, debounceTypingDelay);\r\n    });\r\n\r\n    return promise;\r\n  }\r\n\r\n  /*\r\n   * PAGINATION\r\n   * With cursor, the query can have 4 arguments (first, after, last, before), for example:\r\n   *   users (first:20, after:\"YXJyYXljb25uZWN0aW9uOjM=\") {\r\n   *     totalCount\r\n   *     pageInfo {\r\n   *       hasNextPage\r\n   *       endCursor\r\n   *     }\r\n   *     edges {\r\n   *       cursor\r\n   *       node {\r\n   *         name\r\n   *         gender\r\n   *       }\r\n   *     }\r\n   *   }\r\n   * Without cursor, the query can have 3 arguments (first, last, offset), for example:\r\n   *   users (first:20, offset: 10) {\r\n   *     totalCount\r\n   *     pageInfo {\r\n   *       hasNextPage\r\n   *     }\r\n   *     nodes {\r\n   *       name\r\n   *       gender\r\n   *     }\r\n   *   }\r\n   */\r\n  onPaginationChanged(event: Event, args: PaginationChangedArgs) {\r\n    const pageSize = +args.pageSize || ((this.pagination) ? this.pagination.pageSize : DEFAULT_PAGE_SIZE);\r\n    this.updatePagination(args.newPage, pageSize);\r\n\r\n    // build the GraphQL query which we will use in the WebAPI callback\r\n    return this.buildQuery();\r\n  }\r\n\r\n  /*\r\n   * SORTING\r\n   * we will use sorting as per a Facebook suggestion on a Github issue (with some small changes)\r\n   * https://github.com/graphql/graphql-relay-js/issues/20#issuecomment-220494222\r\n   */\r\n  onSortChanged(event: Event, args: SortChangedArgs) {\r\n    const sortColumns = (args.multiColumnSort) ? args.sortCols : new Array({ sortCol: args.sortCol, sortAsc: args.sortAsc });\r\n\r\n    // loop through all columns to inspect sorters & set the query\r\n    this.updateSorters(sortColumns);\r\n\r\n    // build the GraphQL query which we will use in the WebAPI callback\r\n    return this.buildQuery();\r\n  }\r\n\r\n  /**\r\n   * loop through all columns to inspect filters & update backend service filteringOptions\r\n   * @param columnFilters\r\n   */\r\n  updateFilters(columnFilters: ColumnFilters | CurrentFilter[], isUpdatedByPreset: boolean) {\r\n    // keep current filters & always save it as an array (columnFilters can be an object when it is dealt by SlickGrid Filter)\r\n    this._currentFilters = this.castFilterToColumnFilter(columnFilters);\r\n\r\n    const searchByArray: GraphqlFilteringOption[] = [];\r\n    let searchValue: string | string[];\r\n\r\n    for (const columnId in columnFilters) {\r\n      if (columnFilters.hasOwnProperty(columnId)) {\r\n        const columnFilter = columnFilters[columnId];\r\n\r\n        // if user defined some \"presets\", then we need to find the filters from the column definitions instead\r\n        let columnDef: Column | undefined;\r\n        if (isUpdatedByPreset && Array.isArray(this._columnDefinitions)) {\r\n          columnDef = this._columnDefinitions.find((column: Column) => {\r\n            return column.id === columnFilter.columnId;\r\n          });\r\n        } else {\r\n          columnDef = columnFilter.columnDef;\r\n        }\r\n        if (!columnDef) {\r\n          throw new Error('[Backend Service API]: Something went wrong in trying to get the column definition of the specified filter (or preset filters). Did you make a typo on the filter columnId?');\r\n        }\r\n\r\n        const fieldName = columnDef.queryField || columnDef.field || columnDef.name || '';\r\n        const searchTerms = (columnFilter ? columnFilter.searchTerms : null) || [];\r\n        let fieldSearchValue = columnFilter.searchTerm;\r\n        if (typeof fieldSearchValue === 'undefined') {\r\n          fieldSearchValue = '';\r\n        }\r\n\r\n        if (typeof fieldSearchValue !== 'string' && !searchTerms) {\r\n          throw new Error(`GraphQL filter searchTerm property must be provided as type \"string\", if you use filter with options then make sure your IDs are also string. For example: filter: {type: FilterType.select, collection: [{ id: \"0\", value: \"0\" }, { id: \"1\", value: \"1\" }]`);\r\n        }\r\n\r\n        fieldSearchValue = '' + fieldSearchValue; // make sure it's a string\r\n        const matches = fieldSearchValue.match(/^([<>!=\\*]{0,2})(.*[^<>!=\\*])([\\*]?)$/); // group 1: Operator, 2: searchValue, 3: last char is '*' (meaning starts with, ex.: abc*)\r\n        let operator = columnFilter.operator || ((matches) ? matches[1] : '');\r\n        searchValue = (!!matches) ? matches[2] : '';\r\n        const lastValueChar = (!!matches) ? matches[3] : '';\r\n\r\n        // no need to query if search value is empty\r\n        if (fieldName && searchValue === '' && searchTerms.length === 0) {\r\n          continue;\r\n        }\r\n\r\n        // when having more than 1 search term (we need to create a CSV string for GraphQL \"IN\" or \"NOT IN\" filter search)\r\n        if (searchTerms && searchTerms.length > 0) {\r\n          searchValue = searchTerms.join(',');\r\n        } else if (typeof searchValue === 'string') {\r\n          // escaping the search value\r\n          searchValue = searchValue.replace(`'`, `''`); // escape single quotes by doubling them\r\n          if (operator === '*' || lastValueChar === '*') {\r\n            operator = (operator === '*') ? 'endsWith' : 'startsWith';\r\n          }\r\n        }\r\n\r\n        // if we didn't find an Operator but we have a Filter Type, we should use default Operator\r\n        if (!operator && columnDef.filter) {\r\n          operator = mapOperatorByFilterType(columnDef.filter.type || '');\r\n        }\r\n\r\n        searchByArray.push({\r\n          field: fieldName,\r\n          operator: mapOperatorType(operator),\r\n          value: searchValue\r\n        });\r\n      }\r\n    }\r\n\r\n    // update the service options with filters for the buildQuery() to work later\r\n    this.updateOptions({ filteringOptions: searchByArray });\r\n  }\r\n\r\n  /**\r\n   * Update the pagination component with it's new page number and size\r\n   * @param newPage\r\n   * @param pageSize\r\n   */\r\n  updatePagination(newPage: number, pageSize: number) {\r\n    this._currentPagination = {\r\n      pageNumber: newPage,\r\n      pageSize\r\n    };\r\n\r\n    let paginationOptions;\r\n    if (this.options.isWithCursor) {\r\n      paginationOptions = {\r\n        first: pageSize\r\n      };\r\n    } else {\r\n      paginationOptions = {\r\n        first: pageSize,\r\n        offset: (newPage - 1) * pageSize\r\n      };\r\n    }\r\n\r\n    this.updateOptions({ paginationOptions });\r\n  }\r\n\r\n  /**\r\n   * loop through all columns to inspect sorters & update backend service sortingOptions\r\n   * @param columnFilters\r\n   */\r\n  updateSorters(sortColumns?: SortChanged[], presetSorters?: CurrentSorter[]) {\r\n    let currentSorters: CurrentSorter[] = [];\r\n    let graphqlSorters: GraphqlSortingOption[] = [];\r\n\r\n    if (!sortColumns && presetSorters) {\r\n      // make the presets the current sorters, also make sure that all direction are in uppercase for GraphQL\r\n      currentSorters = presetSorters;\r\n      currentSorters.forEach((sorter) => sorter.direction = sorter.direction.toUpperCase() as SortDirectionString);\r\n\r\n      // display the correct sorting icons on the UI, for that it requires (columnId, sortAsc) properties\r\n      const tmpSorterArray = currentSorters.map((sorter) => {\r\n        return {\r\n          columnId: sorter.columnId,\r\n          sortAsc: sorter.direction.toUpperCase() === SortDirection.ASC\r\n        };\r\n      });\r\n      this._grid.setSortColumns(tmpSorterArray);\r\n    } else if (sortColumns && !presetSorters) {\r\n      // build the orderBy array, it could be multisort, example\r\n      // orderBy:[{field: lastName, direction: ASC}, {field: firstName, direction: DESC}]\r\n      if (sortColumns && sortColumns.length === 0) {\r\n        graphqlSorters = new Array(this.defaultOrderBy); // when empty, use the default sort\r\n        currentSorters = new Array({ columnId: this.defaultOrderBy.direction, direction: this.defaultOrderBy.direction });\r\n      } else {\r\n        if (sortColumns) {\r\n          for (const column of sortColumns) {\r\n            if (column && column.sortCol) {\r\n              currentSorters.push({\r\n                columnId: (column.sortCol.queryField || column.sortCol.field || column.sortCol.id) + '',\r\n                direction: column.sortAsc ? SortDirection.ASC : SortDirection.DESC\r\n              });\r\n\r\n              graphqlSorters.push({\r\n                field: (column.sortCol.queryField || column.sortCol.field || column.sortCol.id) + '',\r\n                direction: column.sortAsc ? SortDirection.ASC : SortDirection.DESC\r\n              });\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // keep current Sorters and update the service options with the new sorting\r\n    this._currentSorters = currentSorters;\r\n    this.updateOptions({ sortingOptions: graphqlSorters });\r\n  }\r\n\r\n  /**\r\n   * A function which takes an input string and removes double quotes only\r\n   * on certain fields are identified as GraphQL enums (except fields with dot notation)\r\n   * For example let say we identified (\"direction:\", \"sort\") as word which are GraphQL enum fields\r\n   * then the result will be:\r\n   * FROM\r\n   * query { users (orderBy:[{field:\"firstName\", direction:\"ASC\"} }]) }\r\n   * TO\r\n   * query { users (orderBy:[{field: firstName, direction: ASC}})}\r\n   *\r\n   * EXCEPTIONS (fields with dot notation \".\" which are inside a \"field:\")\r\n   * these fields will keep double quotes while everything else will be stripped of double quotes\r\n   * query { users (orderBy:[{field:\"billing.street.name\", direction: \"ASC\"} }\r\n   * TO\r\n   * query { users (orderBy:[{field:\"billing.street.name\", direction: ASC}}\r\n   * @param inputStr input string\r\n   * @param enumSearchWords array of enum words to filter\r\n   * @returns outputStr output string\r\n   */\r\n  trimDoubleQuotesOnEnumField(inputStr: string, enumSearchWords: string[], keepArgumentFieldDoubleQuotes: boolean) {\r\n    const patternWordInQuotes = `\\s?((field:\\s*)?\".*?\")`;\r\n    let patternRegex = enumSearchWords.join(patternWordInQuotes + '|');\r\n    patternRegex += patternWordInQuotes; // the last one should also have the pattern but without the pipe \"|\"\r\n    // example with (field: & direction:):  /field:s?(\".*?\")|direction:s?(\".*?\")/\r\n    const reg = new RegExp(patternRegex, 'g');\r\n\r\n    return inputStr.replace(reg, (group1, group2, group3) => {\r\n      // remove double quotes except when the string starts with a \"field:\"\r\n      let removeDoubleQuotes = true;\r\n      if (group1.startsWith('field:') && keepArgumentFieldDoubleQuotes) {\r\n        removeDoubleQuotes = false;\r\n      }\r\n      const rep = removeDoubleQuotes ? group1.replace(/\"/g, '') : group1;\r\n      return rep;\r\n    });\r\n  }\r\n\r\n  //\r\n  // private functions\r\n  // -------------------\r\n  /**\r\n   * Cast provided filters (could be in multiple format) into an array of ColumnFilter\r\n   * @param columnFilters\r\n   */\r\n  private castFilterToColumnFilter(columnFilters: ColumnFilters | CurrentFilter[]): CurrentFilter[] {\r\n    // keep current filters & always save it as an array (columnFilters can be an object when it is dealt by SlickGrid Filter)\r\n    const filtersArray: ColumnFilter[] = (typeof columnFilters === 'object') ? Object.keys(columnFilters).map(key => columnFilters[key]) : columnFilters;\r\n\r\n    return filtersArray.map((filter) => {\r\n      const tmpFilter: CurrentFilter = { columnId: filter.columnId || '' };\r\n      if (filter.operator) {\r\n        tmpFilter.operator = filter.operator;\r\n      }\r\n      if (Array.isArray(filter.searchTerms)) {\r\n        tmpFilter.searchTerms = filter.searchTerms;\r\n      } else {\r\n        tmpFilter.searchTerm = filter.searchTerm;\r\n      }\r\n      return tmpFilter;\r\n    });\r\n  }\r\n}\r\n",
    "import './global-utilities';\r\nimport { CaseType, OdataOption } from './../models/index';\r\n\r\nexport class OdataService {\r\n  _columnFilters: any;\r\n  _defaultSortBy: string;\r\n  _odataOptions: OdataOption;\r\n\r\n  constructor() {\r\n    this._odataOptions = {\r\n      filterQueue: [],\r\n      orderBy: ''\r\n    };\r\n    this._defaultSortBy = '';\r\n    this._columnFilters = {};\r\n  }\r\n\r\n  /*\r\n    * Build the OData query string from all the options provided\r\n    * @return string OData query\r\n    */\r\n  buildQuery(): string {\r\n    this._odataOptions.filterQueue = [];\r\n    const queryTmpArray = [];\r\n\r\n    if (this._odataOptions.top) {\r\n      queryTmpArray.push(`$top=${this._odataOptions.top}`);\r\n    }\r\n    if (this._odataOptions.skip) {\r\n      queryTmpArray.push(`$skip=${this._odataOptions.skip}`);\r\n    }\r\n    if (this._odataOptions.orderBy) {\r\n      let argument = '';\r\n      if (Array.isArray(this._odataOptions.orderBy)) {\r\n        argument = this._odataOptions.orderBy.join(','); // csv, that will form a query example like: $orderby=RoleName asc, Id desc\r\n      } else {\r\n        argument = this._odataOptions.orderBy;\r\n      }\r\n      queryTmpArray.push(`$orderby=${argument}`);\r\n    }\r\n    if (this._odataOptions.filterBy || this._odataOptions.filter) {\r\n      if (this._odataOptions.filter) {\r\n        this._odataOptions.filterQueue = [];\r\n        let filterStr = this._odataOptions.filter;\r\n        if (Array.isArray(this._odataOptions.filter)) {\r\n          filterStr = this._odataOptions.filter.join(` ${this._odataOptions.filterBySeparator || 'and'} `);\r\n        }\r\n        this._odataOptions.filterQueue.push(`(${filterStr})`);\r\n      }\r\n      // filterBy are passed manually by the user, however we will only add it if the column wasn't yet filtered\r\n      if (!!this._odataOptions.filterBy && !!this._odataOptions.filterBy.fieldName && !this._columnFilters[this._odataOptions.filterBy.fieldName.toLowerCase()]) {\r\n        if (this._odataOptions.filterBy.searchTerm !== '') {\r\n          this.saveColumnFilter(this._odataOptions.filterBy.fieldName.toLowerCase(), this._odataOptions.filterBy.searchTerm, this._odataOptions.filterBy.searchTerms);\r\n          this.updateFilterFromListTerms(this._odataOptions.filterBy);\r\n        }\r\n      }\r\n    }\r\n    if (this._odataOptions.filterQueue.length > 0) {\r\n      const query = this._odataOptions.filterQueue.join(` ${this._odataOptions.filterBySeparator || 'and'} `);\r\n      this._odataOptions.filter = query; // overwrite with\r\n      queryTmpArray.push(`$filter=${query}`);\r\n    }\r\n\r\n    // join all the odata functions by a '&'\r\n    return queryTmpArray.join('&');\r\n  }\r\n\r\n  getFilterByColumn(columnName: string): string {\r\n    return (!!this._columnFilters[columnName]) ? this._columnFilters[columnName] : null;\r\n  }\r\n\r\n  getFilterCount(): number {\r\n    return (this._odataOptions.filterQueue) ? this._odataOptions.filterQueue.length : 0;\r\n  }\r\n\r\n  get columnFilters(): any[] {\r\n    return this._columnFilters;\r\n  }\r\n\r\n  get options(): OdataOption {\r\n    return this._odataOptions;\r\n  }\r\n\r\n  set options(options: OdataOption) {\r\n    this._odataOptions = options;\r\n  }\r\n\r\n  removeColumnFilter(fieldName: string) {\r\n    delete this._columnFilters[fieldName];\r\n  }\r\n\r\n  saveColumnFilter(fieldName: string, value: any, searchTerms?: any[]) {\r\n    this._columnFilters[fieldName] = {\r\n      search: searchTerms,\r\n      value\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Update the filter by a list of terms usually passed manually by the user as default filters\r\n   * @param filterOptions\r\n   * @returns\r\n   */\r\n  updateFilterFromListTerms(filterOptions: any) {\r\n    // build the filter query\r\n    if (Array.isArray(filterOptions)) {\r\n      filterOptions.forEach((filterOptionObject) => {\r\n        this.updateFilterFromTerm(filterOptionObject);\r\n      });\r\n    } else {\r\n      this.updateFilterFromTerm(filterOptions);\r\n    }\r\n  }\r\n\r\n  updateFilterFromTerm(filterOptions: any) {\r\n    let searchBy = '';\r\n    const tmpSearchByArray = [];\r\n    const fieldName = filterOptions.fieldName;\r\n    const fieldSearchTerms = filterOptions.searchTerms;\r\n    const operator = filterOptions.operator;\r\n\r\n    // when having more than 1 search term (then check if we have a \"IN\" or \"NOT IN\" filter search)\r\n    if (!!fieldSearchTerms && fieldSearchTerms.length > 0) {\r\n      const tmpSearchTerms = [];\r\n\r\n      if (operator === 'IN') {\r\n        // example:: (Stage eq \"Expired\" or Stage eq \"Renewal\")\r\n        for (let j = 0, lnj = fieldSearchTerms.length; j < lnj; j++) {\r\n          tmpSearchTerms.push(`${fieldName} eq '${fieldSearchTerms[j]}'`);\r\n        }\r\n        searchBy = tmpSearchTerms.join(' or ');\r\n        searchBy = `$(${searchBy})`;\r\n      } else if (operator === 'NIN' || operator === 'NOTIN' || operator === 'NOT IN') {\r\n        // example:: (Stage ne \"Expired\" and Stage ne \"Renewal\")\r\n        for (let k = 0, lnk = fieldSearchTerms.length; k < lnk; k++) {\r\n          tmpSearchTerms.push(`${fieldName} ne '${fieldSearchTerms[k]}'`);\r\n        }\r\n        searchBy = tmpSearchTerms.join(' and ');\r\n        searchBy = `$(${searchBy})`;\r\n      }\r\n    }\r\n\r\n    // push to our temp array and also trim white spaces\r\n    tmpSearchByArray.push(String.trim(searchBy));\r\n\r\n    // add to the filter queue only if it doesn't exist in the queue\r\n    const filter = (tmpSearchByArray.length > 0) ? tmpSearchByArray.join(' and ') : '';\r\n    if (this._odataOptions.filterQueue && this._odataOptions.filterQueue.indexOf(filter) === -1) {\r\n      this._odataOptions.filterQueue.push(filter);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Change any OData options that will be used to build the query\r\n   * @param object options\r\n   */\r\n  updateOptions(options: OdataOption) {\r\n    for (const property of Object.keys(options)) {\r\n      if (options.hasOwnProperty(property)) {\r\n        this._odataOptions[property] = options[property]; // replace of the property\r\n      }\r\n\r\n      // we need to keep the defaultSortBy for references whenever the user removes his Sorting\r\n      // then we would revert to the defaultSortBy and the only way is to keep a hard copy here\r\n      if (property === 'orderBy' || property === 'sortBy') {\r\n        let sortBy = options[property];\r\n\r\n        // make sure first char of each orderBy field is capitalize\r\n        if (this._odataOptions.caseType === CaseType.pascalCase) {\r\n          if (Array.isArray(sortBy)) {\r\n            sortBy.forEach((field, index, inputArray) => {\r\n              inputArray[index] = String.titleCase(field);\r\n            });\r\n          } else {\r\n            sortBy = String.titleCase(options[property]);\r\n          }\r\n        }\r\n        this._odataOptions.orderBy = sortBy;\r\n        this._defaultSortBy = sortBy;\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n",
    "declare interface StringConstructor {\r\n  allTitleCase(inputStr: string): string;\r\n  format(inputStr: string, args: any): string;\r\n  padZero(length: number): string;\r\n  trim(inputStr: string): string;\r\n  titleCase(inputStr: string): string;\r\n}\r\n\r\n\r\nString.format = function(format: string, args): string {\r\n  // const args = (Array.isArray(arguments[1])) ? arguments[1] : Array.prototype.slice.call(arguments, 1);\r\n\r\n  return format.replace(/{(\\d+)}/g, function (match, number) {\r\n    return (typeof args[number] !== 'undefined') ? args[number] : match;\r\n  });\r\n};\r\n\r\nString.padZero = function (this: string, length: number) {\r\n  let s = this;\r\n  while (s.length < length) {\r\n    s = '0' + s;\r\n  }\r\n  return s;\r\n};\r\n\r\n/**\r\n * Trim any extra white space from the string\r\n * @param string inputStr\r\n * @returns string outputStr\r\n */\r\nString.trim = function(inputStr: string): string {\r\n  return inputStr ? inputStr.replace(/\\s+/g, ' ') : inputStr;\r\n};\r\n\r\n/**\r\n * Title case the complete sentence (upper case first char of each word while changing everything else to lower case)\r\n * @param string inputStr\r\n * @returns string outputStr\r\n */\r\nString.allTitleCase = function(inputStr: string): string {\r\n  return inputStr.replace(/\\w\\S*/g, function(outputStr) {\r\n     return outputStr.charAt(0).toUpperCase() + outputStr.substr(1).toLowerCase();\r\n  });\r\n};\r\n\r\n/**\r\n * Title case the complete sentence (upper case first char of each word while changing everything else to lower case)\r\n * @param string inputStr\r\n * @returns string outputStr\r\n*/\r\nString.titleCase = function(inputStr: string): string {\r\n  return inputStr.charAt(0).toUpperCase() + inputStr.slice(1);\r\n};\r\n",
    "import './global-utilities';\r\nimport { parseUtcDate } from './utilities';\r\nimport { Injectable } from '@angular/core';\r\nimport {\r\n  BackendService,\r\n  CaseType,\r\n  Column,\r\n  ColumnFilter,\r\n  ColumnFilters,\r\n  CurrentFilter,\r\n  CurrentPagination,\r\n  CurrentSorter,\r\n  FilterChangedArgs,\r\n  FieldType,\r\n  GridOption,\r\n  OdataOption,\r\n  Pagination,\r\n  PaginationChangedArgs,\r\n  SearchTerm,\r\n  SortChanged,\r\n  SortChangedArgs,\r\n  SortDirection,\r\n  SortDirectionString\r\n} from './../models/index';\r\nimport { OdataService } from './odata.service';\r\n\r\nlet timer: any;\r\nconst DEFAULT_FILTER_TYPING_DEBOUNCE = 750;\r\nconst DEFAULT_ITEMS_PER_PAGE = 25;\r\nconst DEFAULT_PAGE_SIZE = 20;\r\n\r\n@Injectable()\r\nexport class GridOdataService implements BackendService {\r\n  private _currentFilters: CurrentFilter[];\r\n  private _currentPagination: CurrentPagination;\r\n  private _currentSorters: CurrentSorter[];\r\n  private _columnDefinitions: Column[];\r\n  private _gridOptions: GridOption;\r\n  private _grid: any;\r\n  options: OdataOption;\r\n  pagination: Pagination | undefined;\r\n  defaultOptions: OdataOption = {\r\n    top: DEFAULT_ITEMS_PER_PAGE,\r\n    orderBy: '',\r\n    caseType: CaseType.pascalCase\r\n  };\r\n\r\n  constructor(private odataService: OdataService) { }\r\n\r\n  buildQuery(): string {\r\n    return this.odataService.buildQuery();\r\n  }\r\n\r\n  init(options: OdataOption, pagination?: Pagination, grid?: any): void {\r\n    this._grid = grid;\r\n    const mergedOptions = { ...this.defaultOptions, ...options };\r\n    this.odataService.options = { ...mergedOptions, top: mergedOptions.top || (pagination ? pagination.pageSize : null) || this.defaultOptions.top };\r\n    this.options = this.odataService.options;\r\n    this.pagination = pagination;\r\n\r\n    if (grid && grid.getColumns && grid.getOptions) {\r\n      this._columnDefinitions = grid.getColumns() || options.columnDefinitions;\r\n      this._columnDefinitions = this._columnDefinitions.filter((column: Column) => !column.excludeFromQuery);\r\n\r\n      this._gridOptions = grid.getOptions();\r\n    }\r\n  }\r\n\r\n  updateOptions(serviceOptions?: OdataOption) {\r\n    this.options = { ...this.options, ...serviceOptions };\r\n  }\r\n\r\n  removeColumnFilter(fieldName: string): void {\r\n    this.odataService.removeColumnFilter(fieldName);\r\n  }\r\n\r\n  /** Get the Filters that are currently used by the grid */\r\n  getCurrentFilters(): CurrentFilter[] {\r\n    return this._currentFilters;\r\n  }\r\n\r\n  /** Get the Pagination that is currently used by the grid */\r\n  getCurrentPagination(): CurrentPagination {\r\n    return this._currentPagination;\r\n  }\r\n\r\n  /** Get the Sorters that are currently used by the grid */\r\n  getCurrentSorters(): CurrentSorter[] {\r\n    return this._currentSorters;\r\n  }\r\n\r\n  /*\r\n   * Reset the pagination options\r\n   */\r\n  resetPaginationOptions() {\r\n    this.odataService.updateOptions({\r\n      skip: 0\r\n    });\r\n  }\r\n\r\n  saveColumnFilter(fieldName: string, value: string, terms?: any[]) {\r\n    this.odataService.saveColumnFilter(fieldName, value, terms);\r\n  }\r\n\r\n  /*\r\n   * FILTERING\r\n   */\r\n  onFilterChanged(event: Event, args: FilterChangedArgs): Promise<string> {\r\n    const serviceOptions: GridOption = args.grid.getOptions();\r\n    const backendApi = serviceOptions.backendServiceApi || serviceOptions.onBackendEventApi;\r\n\r\n    if (backendApi === undefined) {\r\n      throw new Error('Something went wrong in the GridOdataService, \"backendServiceApi\" is not initialized');\r\n    }\r\n\r\n    // only add a delay when user is typing, on select dropdown filter it will execute right away\r\n    let debounceTypingDelay = 0;\r\n    if (event && (event.type === 'keyup' || event.type === 'keydown')) {\r\n      debounceTypingDelay = backendApi.filterTypingDebounce || DEFAULT_FILTER_TYPING_DEBOUNCE;\r\n    }\r\n\r\n    const promise = new Promise<string>((resolve, reject) => {\r\n      // loop through all columns to inspect filters & set the query\r\n      this.updateFilters(args.columnFilters);\r\n\r\n      // reset Pagination, then build the OData query which we will use in the WebAPI callback\r\n      // wait a minimum user typing inactivity before processing any query\r\n      clearTimeout(timer);\r\n      timer = setTimeout(() => {\r\n        this.resetPaginationOptions();\r\n        resolve(this.odataService.buildQuery());\r\n      }, debounceTypingDelay);\r\n    });\r\n\r\n    return promise;\r\n  }\r\n\r\n  /*\r\n   * PAGINATION\r\n   */\r\n  onPaginationChanged(event: Event, args: PaginationChangedArgs) {\r\n    const pageSize = +args.pageSize || DEFAULT_PAGE_SIZE;\r\n    this.updatePagination(args.newPage, pageSize);\r\n\r\n    // build the OData query which we will use in the WebAPI callback\r\n    return this.odataService.buildQuery();\r\n  }\r\n\r\n  /*\r\n   * SORTING\r\n   */\r\n  onSortChanged(event: Event, args: SortChangedArgs) {\r\n    const sortColumns = (args.multiColumnSort) ? args.sortCols : new Array({ sortCol: args.sortCol, sortAsc: args.sortAsc });\r\n\r\n    // loop through all columns to inspect sorters & set the query\r\n    this.updateSorters(sortColumns);\r\n\r\n    // build the OData query which we will use in the WebAPI callback\r\n    return this.odataService.buildQuery();\r\n  }\r\n\r\n  /**\r\n   * loop through all columns to inspect filters & update backend service filteringOptions\r\n   * @param columnFilters\r\n   */\r\n  updateFilters(columnFilters: ColumnFilters | CurrentFilter[], isUpdatedByPreset?: boolean) {\r\n    this._currentFilters = this.castFilterToColumnFilter(columnFilters);\r\n    let searchBy = '';\r\n    const searchByArray: string[] = [];\r\n\r\n    // loop through all columns to inspect filters\r\n    for (const columnId in columnFilters) {\r\n      if (columnFilters.hasOwnProperty(columnId)) {\r\n        const columnFilter = columnFilters[columnId];\r\n\r\n        // if user defined some \"presets\", then we need to find the filters from the column definitions instead\r\n        let columnDef: Column | undefined;\r\n        if (isUpdatedByPreset && Array.isArray(this._columnDefinitions)) {\r\n          columnDef = this._columnDefinitions.find((column: Column) => {\r\n            return column.id === columnFilter.columnId;\r\n          });\r\n        } else {\r\n          columnDef = columnFilter.columnDef;\r\n        }\r\n        if (!columnDef) {\r\n          throw new Error('[Backend Service API]: Something went wrong in trying to get the column definition of the specified filter (or preset filters). Did you make a typo on the filter columnId?');\r\n        }\r\n\r\n        let fieldName = columnDef.queryField || columnDef.field || columnDef.name || '';\r\n        const fieldType = columnDef.type || 'string';\r\n        const searchTerms = (columnFilter ? columnFilter.searchTerms : null) || [];\r\n        let fieldSearchValue = columnFilter.searchTerm;\r\n        if (typeof fieldSearchValue === 'undefined') {\r\n          fieldSearchValue = '';\r\n        }\r\n\r\n        if (typeof fieldSearchValue !== 'string' && !searchTerms) {\r\n          throw new Error(`ODdata filter searchTerm property must be provided as type \"string\", if you use filter with options then make sure your IDs are also string. For example: filter: {type: FilterType.select, collection: [{ id: \"0\", value: \"0\" }, { id: \"1\", value: \"1\" }]`);\r\n        }\r\n\r\n        fieldSearchValue = '' + fieldSearchValue; // make sure it's a string\r\n        const matches = fieldSearchValue.match(/^([<>!=\\*]{0,2})(.*[^<>!=\\*])([\\*]?)$/); // group 1: Operator, 2: searchValue, 3: last char is '*' (meaning starts with, ex.: abc*)\r\n        const operator = columnFilter.operator || ((matches) ? matches[1] : '');\r\n        let searchValue = (!!matches) ? matches[2] : '';\r\n        const lastValueChar = (!!matches) ? matches[3] : '';\r\n        const bypassOdataQuery = columnFilter.bypassBackendQuery || false;\r\n\r\n        // no need to query if search value is empty\r\n        if (fieldName && searchValue === '') {\r\n          this.removeColumnFilter(fieldName);\r\n          continue;\r\n        }\r\n\r\n        // escaping the search value\r\n        searchValue = searchValue.replace(`'`, `''`); // escape single quotes by doubling them\r\n        searchValue = encodeURIComponent(searchValue); // encode URI of the final search value\r\n\r\n        // extra query arguments\r\n        if (bypassOdataQuery) {\r\n          // push to our temp array and also trim white spaces\r\n          if (fieldName) {\r\n            this.saveColumnFilter(fieldName, fieldSearchValue, searchTerms);\r\n          }\r\n        } else {\r\n          searchBy = '';\r\n\r\n          // titleCase the fieldName so that it matches the WebApi names\r\n          if (this.odataService.options.caseType === CaseType.pascalCase) {\r\n            fieldName = String.titleCase(fieldName || '');\r\n          }\r\n\r\n          // when having more than 1 search term (then check if we have a \"IN\" or \"NOT IN\" filter search)\r\n          if (searchTerms && searchTerms.length > 0) {\r\n            const tmpSearchTerms = [];\r\n\r\n            if (operator === 'IN') {\r\n              // example:: (Stage eq \"Expired\" or Stage eq \"Renewal\")\r\n              for (let j = 0, lnj = searchTerms.length; j < lnj; j++) {\r\n                tmpSearchTerms.push(`${fieldName} eq '${searchTerms[j]}'`);\r\n              }\r\n              searchBy = tmpSearchTerms.join(' or ');\r\n              searchBy = `(${searchBy})`;\r\n            } else if (operator === 'NIN' || operator === 'NOTIN' || operator === 'NOT IN') {\r\n              // example:: (Stage ne \"Expired\" and Stage ne \"Renewal\")\r\n              for (let k = 0, lnk = searchTerms.length; k < lnk; k++) {\r\n                tmpSearchTerms.push(`${fieldName} ne '${searchTerms[k]}'`);\r\n              }\r\n              searchBy = tmpSearchTerms.join(' and ');\r\n              searchBy = `(${searchBy})`;\r\n            }\r\n          } else if (operator === '*' || lastValueChar !== '') {\r\n            // first/last character is a '*' will be a startsWith or endsWith\r\n            searchBy = operator === '*'\r\n              ? `endswith(${fieldName}, '${searchValue}')`\r\n              : `startswith(${fieldName}, '${searchValue}')`;\r\n          } else if (fieldType === FieldType.date) {\r\n            // date field needs to be UTC and within DateTime function\r\n            const dateFormatted = parseUtcDate(searchValue, true);\r\n            if (dateFormatted) {\r\n              searchBy = `${fieldName} ${this.mapOdataOperator(operator)} DateTime'${dateFormatted}'`;\r\n            }\r\n          } else if (fieldType === FieldType.string) {\r\n            // string field needs to be in single quotes\r\n            if (operator === '') {\r\n              searchBy = `substringof('${searchValue}', ${fieldName})`;\r\n            } else {\r\n              // searchBy = `substringof('${searchValue}', ${fieldNameCased}) ${this.mapOdataOperator(operator)} true`;\r\n              searchBy = `${fieldName} ${this.mapOdataOperator(operator)} '${searchValue}'`;\r\n            }\r\n          } else {\r\n            // any other field type (or undefined type)\r\n            searchValue = fieldType === FieldType.number ? searchValue : `'${searchValue}'`;\r\n            searchBy = `${fieldName} ${this.mapOdataOperator(operator)} ${searchValue}`;\r\n          }\r\n\r\n          // push to our temp array and also trim white spaces\r\n          if (searchBy !== '') {\r\n            searchByArray.push(String.trim(searchBy));\r\n            this.saveColumnFilter(fieldName || '', fieldSearchValue, searchTerms);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // update the service options with filters for the buildQuery() to work later\r\n    this.odataService.updateOptions({\r\n      filter: (searchByArray.length > 0) ? searchByArray.join(' and ') : '',\r\n      skip: undefined\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update the pagination component with it's new page number and size\r\n   * @param newPage\r\n   * @param pageSize\r\n   */\r\n  updatePagination(newPage: number, pageSize: number) {\r\n    this._currentPagination = {\r\n      pageNumber: newPage,\r\n      pageSize\r\n    };\r\n\r\n    this.odataService.updateOptions({\r\n      top: pageSize,\r\n      skip: (newPage - 1) * pageSize\r\n    });\r\n  }\r\n\r\n  /**\r\n   * loop through all columns to inspect sorters & update backend service orderBy\r\n   * @param columnFilters\r\n   */\r\n  updateSorters(sortColumns?: SortChanged[], presetSorters?: CurrentSorter[]) {\r\n    let sortByArray: any[] = [];\r\n    const sorterArray: CurrentSorter[] = [];\r\n\r\n    if (!sortColumns && presetSorters) {\r\n      // make the presets the current sorters, also make sure that all direction are in lowercase for OData\r\n      sortByArray = presetSorters;\r\n      sortByArray.forEach((sorter) => sorter.direction = sorter.direction.toLowerCase() as SortDirectionString);\r\n\r\n      // display the correct sorting icons on the UI, for that it requires (columnId, sortAsc) properties\r\n      const tmpSorterArray = sortByArray.map((sorter) => {\r\n        return {\r\n          columnId: sorter.columnId,\r\n          sortAsc: sorter.direction.toUpperCase() === SortDirection.ASC\r\n        };\r\n      });\r\n      this._grid.setSortColumns(tmpSorterArray);\r\n    } else if (sortColumns && !presetSorters) {\r\n      // build the SortBy string, it could be multisort, example: customerNo asc, purchaserName desc\r\n      if (sortColumns && sortColumns.length === 0) {\r\n        sortByArray = new Array(this.defaultOptions.orderBy); // when empty, use the default sort\r\n      } else {\r\n        if (sortColumns) {\r\n          for (const column of sortColumns) {\r\n            if (column.sortCol) {\r\n              let fieldName = (column.sortCol.queryField || column.sortCol.field || column.sortCol.id) + '';\r\n              if (this.odataService.options.caseType === CaseType.pascalCase) {\r\n                fieldName = String.titleCase(fieldName);\r\n              }\r\n\r\n              sorterArray.push({\r\n                columnId: fieldName,\r\n                direction: column.sortAsc ? 'asc' : 'desc'\r\n              });\r\n            }\r\n          }\r\n          sortByArray = sorterArray;\r\n        }\r\n      }\r\n    }\r\n\r\n    // transform the sortby array into a CSV string for OData\r\n    sortByArray = sortByArray as CurrentSorter[];\r\n    const csvString = sortByArray.map((sorter) => `${sorter.columnId} ${sorter.direction.toLowerCase()}`).join(',');\r\n    this.odataService.updateOptions({\r\n      orderBy: (this.odataService.options.caseType === CaseType.pascalCase) ? String.titleCase(csvString) : csvString\r\n    });\r\n\r\n    // keep current Sorters and update the service options with the new sorting\r\n    this._currentSorters = sortByArray as CurrentSorter[];\r\n\r\n    // build the OData query which we will use in the WebAPI callback\r\n    return this.odataService.buildQuery();\r\n  }\r\n\r\n  //\r\n  // private functions\r\n  // -------------------\r\n  /**\r\n   * Cast provided filters (could be in multiple format) into an array of ColumnFilter\r\n   * @param columnFilters\r\n   */\r\n  private castFilterToColumnFilter(columnFilters: ColumnFilters | CurrentFilter[]): CurrentFilter[] {\r\n    // keep current filters & always save it as an array (columnFilters can be an object when it is dealt by SlickGrid Filter)\r\n    const filtersArray: ColumnFilter[] = ((typeof columnFilters === 'object') ? Object.keys(columnFilters).map(key => columnFilters[key]) : columnFilters) as CurrentFilter[];\r\n\r\n    return filtersArray.map((filter) => {\r\n      const tmpFilter: CurrentFilter = { columnId: filter.columnId || '' };\r\n      if (filter.operator) {\r\n        tmpFilter.operator = filter.operator;\r\n      }\r\n      if (Array.isArray(filter.searchTerms)) {\r\n        tmpFilter.searchTerms = filter.searchTerms;\r\n      } else {\r\n        tmpFilter.searchTerm = filter.searchTerm;\r\n      }\r\n      return tmpFilter;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Mapper for mathematical operators (ex.: <= is \"le\", > is \"gt\")\r\n   * @param string operator\r\n   * @returns string map\r\n   */\r\n  private mapOdataOperator(operator: string) {\r\n    let map = '';\r\n    switch (operator) {\r\n      case '<':\r\n        map = 'lt';\r\n        break;\r\n      case '<=':\r\n        map = 'le';\r\n        break;\r\n      case '>':\r\n        map = 'gt';\r\n        break;\r\n      case '>=':\r\n        map = 'ge';\r\n        break;\r\n      case '<>':\r\n      case '!=':\r\n        map = 'ne';\r\n        break;\r\n      case '=':\r\n      case '==':\r\n      default:\r\n        map = 'eq';\r\n        break;\r\n    }\r\n\r\n    return map;\r\n  }\r\n}\r\n",
    "import { GridOption } from './../models/index';\r\nimport $ from 'jquery';\r\n\r\n// using external non-typed js libraries\r\ndeclare var $: any;\r\ndeclare var Slick: any;\r\n\r\nexport class GridExtraService {\r\n  private _grid: any;\r\n  private _dataView: any;\r\n  private _gridOptions: GridOption;\r\n\r\n  init(grid, columnDefinition, gridOptions, dataView) {\r\n    this._grid = grid;\r\n    this._gridOptions = gridOptions;\r\n    this._dataView = dataView;\r\n  }\r\n\r\n  getDataItemByRowNumber(rowNumber: number) {\r\n    if (!this._grid || typeof this._grid.getDataItem !== 'function') {\r\n      throw new Error('We could not find SlickGrid Grid object');\r\n    }\r\n    return this._grid.getDataItem(rowNumber);\r\n  }\r\n\r\n  /** Chain the item Metadata with our implementation of Metadata at given row index */\r\n  getItemRowMetadata(previousItemMetadata: any) {\r\n    return (rowNumber: number) => {\r\n      const item = this._dataView.getItem(rowNumber);\r\n      let meta = {\r\n        cssClasses: ''\r\n      };\r\n      if (typeof previousItemMetadata === 'object' && !$.isEmptyObject(previousItemMetadata)) {\r\n        meta = previousItemMetadata(rowNumber);\r\n      }\r\n\r\n      if (item && item._dirty) {\r\n        meta.cssClasses = (meta.cssClasses || '') + ' dirty';\r\n      }\r\n      if (item && item.rowClass) {\r\n        meta.cssClasses += ` ${item.rowClass}`;\r\n        meta.cssClasses += ` row${rowNumber}`;\r\n      }\r\n\r\n      return meta;\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Highlight then fade a row for x seconds.\r\n   * The implementation follows this SO answer: https://stackoverflow.com/a/19985148/1212166\r\n   * @param rowNumber\r\n   * @param fadeDelay\r\n   */\r\n  highlightRow(rowNumber: number, fadeDelay: number = 1500) {\r\n    // create a SelectionModel if there's not one yet\r\n    if (!this._grid.getSelectionModel()) {\r\n      const rowSelectionPlugin = new Slick.RowSelectionModel(this._gridOptions.rowSelectionOptions || {});\r\n      this._grid.setSelectionModel(rowSelectionPlugin);\r\n    }\r\n\r\n    this._grid.setSelectedRows([rowNumber]);\r\n    this._dataView.getItemMetadata = this.getItemRowMetadata(this._dataView.getItemMetadata);\r\n\r\n    const item = this._dataView.getItem(rowNumber);\r\n    if (item && item.id) {\r\n      item.rowClass = 'highlight';\r\n      this._dataView.updateItem(item.id, item);\r\n      const gridOptions = this._grid.getOptions() as GridOption;\r\n\r\n      // highlight the row for a user defined timeout\r\n      $(`#${gridOptions.gridId}`)\r\n          .find(`.highlight.row${rowNumber}`)\r\n          .first();\r\n\r\n      // delete the row's CSS that was attached for highlighting\r\n      setTimeout(() => {\r\n        if (item && item.id) {\r\n          delete item.rowClass;\r\n          const gridIdx = this._dataView.getIdxById(item.id);\r\n          if (gridIdx !== undefined) {\r\n            this._dataView.updateItem(item.id, item);\r\n          }\r\n        }\r\n      }, fadeDelay + 10);\r\n    }\r\n  }\r\n\r\n  getSelectedRows() {\r\n    return this._grid.getSelectedRows();\r\n  }\r\n  setSelectedRow(rowIndex: number) {\r\n    this._grid.setSelectedRows([rowIndex]);\r\n  }\r\n  setSelectedRows(rowIndexes: number[]) {\r\n    this._grid.setSelectedRows(rowIndexes);\r\n  }\r\n\r\n  renderGrid() {\r\n    if (this._grid && typeof this._grid.invalidate === 'function') {\r\n      this._grid.invalidate();\r\n      this._grid.render();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add an item (data item) to the datagrid\r\n   * @param object dataItem: item object holding all properties of that row\r\n   */\r\n  addItemToDatagrid(item) {\r\n    if (!this._grid || !this._gridOptions || !this._dataView) {\r\n      throw new Error('We could not find SlickGrid Grid, DataView objects');\r\n    }\r\n    if (!this._gridOptions || (!this._gridOptions.enableCheckboxSelector && !this._gridOptions.enableRowSelection)) {\r\n      throw new Error('addItemToDatagrid() requires to have a valid Slickgrid Selection Model. You can overcome this issue by enabling enableCheckboxSelector or enableRowSelection to True');\r\n    }\r\n\r\n    const row = 0;\r\n    this._dataView.insertItem(row, item);\r\n    this._grid.scrollRowIntoView(0); // scroll to row 0\r\n    this.highlightRow(0, 1500);\r\n\r\n    // refresh dataview & grid\r\n    this._dataView.refresh();\r\n  }\r\n\r\n  /**\r\n   * Update an existing item with new properties inside the datagrid\r\n   * @param object item: item object holding all properties of that row\r\n   */\r\n  updateDataGridItem(item: any) {\r\n    const row = this._dataView.getRowById(item.id);\r\n    const itemId = (!item || !item.hasOwnProperty('id')) ? -1 : item.id;\r\n\r\n    if (itemId === -1) {\r\n      throw new Error(`Could not find the item in the item in the grid or it's associated \"id\"`);\r\n    }\r\n\r\n    const gridIdx = this._dataView.getIdxById(itemId);\r\n    if (gridIdx !== undefined) {\r\n      // Update the item itself inside the dataView\r\n      this._dataView.updateItem(itemId, item);\r\n\r\n      // highlight the row we just updated\r\n      this.highlightRow(row, 1500);\r\n\r\n      // refresh dataview & grid\r\n      this._dataView.refresh();\r\n    }\r\n  }\r\n}\r\n",
    "import { OnEventArgs, CellArgs, GridOption } from './../models/index';\r\n\r\n// using external non-typed js libraries\r\ndeclare var Slick: any;\r\n\r\nexport class GridEventService {\r\n  private _eventHandler: any = new Slick.EventHandler();\r\n\r\n  /* OnCellChange Event */\r\n  attachOnCellChange(grid: any, gridOptions: GridOption, dataView: any) {\r\n    // subscribe to this Slickgrid event of onCellChange\r\n    this._eventHandler.subscribe(grid.onCellChange, (e: Event, args: CellArgs) => {\r\n      if (!e || !args || !args.grid || args.cell === undefined || !args.grid.getColumns || !args.grid.getDataItem) {\r\n        return;\r\n      }\r\n      const column = args.grid.getColumns()[args.cell];\r\n\r\n      // if the column definition has a onCellChange property (a callback function), then run it\r\n      if (typeof column.onCellChange === 'function') {\r\n        // add to the output gridOptions & dataView since we'll need them inside the AJAX column.onCellChange\r\n        const returnedArgs: OnEventArgs = {\r\n          row: args.row,\r\n          cell: args.cell,\r\n          dataView,\r\n          gridDefinition: gridOptions,\r\n          grid,\r\n          columnDef: column,\r\n          dataContext: args.grid.getDataItem(args.row)\r\n        };\r\n\r\n        // finally call up the Slick.column.onCellChanges.... function\r\n        column.onCellChange(returnedArgs);\r\n        // e.stopImmediatePropagation();\r\n      }\r\n    });\r\n  }\r\n  /* OnClick Event */\r\n  attachOnClick(grid: any, gridOptions: GridOption, dataView: any) {\r\n    this._eventHandler.subscribe(grid.onClick, (e: Event, args: CellArgs) => {\r\n      if (!e || !args || !args.grid || args.cell === undefined || !args.grid.getColumns || !args.grid.getDataItem) {\r\n        return;\r\n      }\r\n      const column = args.grid.getColumns()[args.cell];\r\n\r\n      // if the column definition has a onCellClick property (a callback function), then run it\r\n      if (typeof column.onCellClick === 'function') {\r\n        // add to the output gridOptions & dataView since we'll need them inside the AJAX column.onClick\r\n        const returnedArgs: OnEventArgs = {\r\n          row: args.row,\r\n          cell: args.cell,\r\n          dataView,\r\n          gridDefinition: gridOptions,\r\n          grid,\r\n          columnDef: column,\r\n          dataContext: args.grid.getDataItem(args.row)\r\n        };\r\n\r\n        // finally call up the Slick.column.onCellClick.... function\r\n        column.onCellClick(returnedArgs);\r\n        e.stopImmediatePropagation();\r\n      }\r\n\r\n      // stop the click event bubbling\r\n      // NOTE: We don't want to stop bubbling when doing an input edit, if we do the autoEdit which has intent of doing singleClick edit will become doubleClick edit\r\n      if (grid.getOptions && !grid.getOptions().autoEdit) {\r\n        // e.stopImmediatePropagation();\r\n      }\r\n    });\r\n  }\r\n\r\n  dispose() {\r\n    this._eventHandler.unsubscribeAll();\r\n  }\r\n}\r\n",
    "import { mapMomentDateFormatWithFieldType } from './../services/utilities';\r\nimport { FieldType, Sorter } from './../models/index';\r\nimport * as moment_ from 'moment-mini';\r\nconst moment = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\nconst FORMAT = mapMomentDateFormatWithFieldType(FieldType.dateUsShort);\r\n\r\nexport const dateUsShortSorter: Sorter = (value1, value2, sortDirection) => {\r\n  if (!moment(value1, FORMAT, true).isValid() || !moment(value2, FORMAT, true).isValid()) {\r\n    return 0;\r\n  }\r\n  const date1 = moment(value1, FORMAT, true);\r\n  const date2 = moment(value2, FORMAT, true);\r\n  const diff = parseInt(date1.format('X'), 10) - parseInt(date2.format('X'), 10);\r\n\r\n  return sortDirection * (diff === 0 ? 0 : (diff > 0 ? 1 : -1));\r\n};\r\n",
    "import { CellArgs } from './../models/index';\r\n\r\nexport class GridExtraUtils {\r\n  static getColumnDefinitionAndData(args: CellArgs) {\r\n    if (!args || !args.grid || !args.grid.getColumns || !args.grid.getDataItem) {\r\n      throw new Error('To get the column definition and data, we need to have these arguments passed (row, cell, grid)');\r\n    }\r\n    return {\r\n      columnDef: args.grid.getColumns()[args.cell],\r\n      dataContext: args.grid.getDataItem(args.row)\r\n    };\r\n  }\r\n}\r\n",
    "import {\r\n  CurrentFilter,\r\n  CurrentPagination,\r\n  CurrentSorter,\r\n  GridOption,\r\n  GridState\r\n} from './../models/index';\r\nimport { FilterService, SortService } from './../services/index';\r\nimport $ from 'jquery';\r\n\r\nexport class GridStateService {\r\n  private _grid: any;\r\n  private _gridOptions: GridOption;\r\n  private _preset: GridState;\r\n  private filterService: FilterService;\r\n  private sortService: SortService;\r\n\r\n  /**\r\n   * Initialize the Export Service\r\n   * @param grid\r\n   * @param gridOptions\r\n   * @param dataView\r\n   */\r\n  init(grid: any, filterService: FilterService, sortService: SortService): void {\r\n    this._grid = grid;\r\n    this.filterService = filterService;\r\n    this.sortService = sortService;\r\n    this._gridOptions = (grid && grid.getOptions) ? grid.getOptions() : {};\r\n  }\r\n\r\n  /**\r\n   * Get the current grid state (filters/sorters/pagination)\r\n   * @return grid state\r\n   */\r\n  getCurrentGridState(): GridState {\r\n    const gridState: GridState = {\r\n      filters: this.getCurrentFilters(),\r\n      sorters: this.getCurrentSorters()\r\n    };\r\n\r\n    const currentPagination = this.getCurrentPagination();\r\n    if (currentPagination) {\r\n      gridState.pagination = currentPagination;\r\n    }\r\n    return gridState;\r\n  }\r\n\r\n  /**\r\n   * Get the Filters (and their state, columnId, searchTerm(s)) that are currently applied in the grid\r\n   * @return current filters\r\n   */\r\n  getCurrentFilters(): CurrentFilter[] | null {\r\n    if (this._gridOptions && this._gridOptions.backendServiceApi) {\r\n      const backendService = this._gridOptions.backendServiceApi.service;\r\n      if (backendService && backendService.getCurrentFilters) {\r\n        return backendService.getCurrentFilters() as CurrentFilter[];\r\n      }\r\n    } else if (this.filterService && this.filterService.getCurrentLocalFilters) {\r\n      return this.filterService.getCurrentLocalFilters();\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Get current Pagination (and it's state, pageNumber, pageSize) that are currently applied in the grid\r\n   * @return current pagination state\r\n   */\r\n  getCurrentPagination(): CurrentPagination | null {\r\n    if (this._gridOptions && this._gridOptions.backendServiceApi) {\r\n      const backendService = this._gridOptions.backendServiceApi.service;\r\n      if (backendService && backendService.getCurrentPagination) {\r\n        return backendService.getCurrentPagination();\r\n      }\r\n    } else {\r\n      // TODO implement this whenever local pagination gets implemented\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Get the current Sorters (and their state, columnId, direction) that are currently applied in the grid\r\n   * @return current sorters\r\n   */\r\n  getCurrentSorters(): CurrentSorter[] | null {\r\n    if (this._gridOptions && this._gridOptions.backendServiceApi) {\r\n      const backendService = this._gridOptions.backendServiceApi.service;\r\n      if (backendService && backendService.getCurrentSorters) {\r\n        return backendService.getCurrentSorters() as CurrentSorter[];\r\n      }\r\n    } else if (this.sortService && this.sortService.getCurrentLocalSorters) {\r\n      return this.sortService.getCurrentLocalSorters();\r\n    }\r\n    return null;\r\n  }\r\n}\r\n",
    "import { GridOption } from './../models/index';\r\nimport $ from 'jquery';\r\ndeclare var $: any;\r\n\r\n// global constants, height/width are in pixels\r\nconst DATAGRID_MIN_HEIGHT = 180;\r\nconst DATAGRID_MIN_WIDTH = 300;\r\nconst DATAGRID_BOTTOM_PADDING = 20;\r\nconst DATAGRID_PAGINATION_HEIGHT = 35;\r\nlet timer: any;\r\n\r\nexport class ResizerService {\r\n  private _grid: any;\r\n  private _gridOptions: GridOption;\r\n\r\n  init(grid: any, gridOptions: GridOption): void {\r\n    this._grid = grid;\r\n    this._gridOptions = gridOptions;\r\n  }\r\n\r\n  /** Attach an auto resize trigger on the datagrid, if that is enable then it will resize itself to the available space\r\n   * Options: we could also provide a % factor to resize on each height/width independently\r\n   */\r\n  attachAutoResizeDataGrid() {\r\n    // if we can't find the grid to resize, return without attaching anything\r\n    const gridDomElm = $(`#${this._gridOptions && this._gridOptions.gridId ? this._gridOptions.gridId : 'grid1'}`);\r\n    if (gridDomElm === undefined || gridDomElm.offset() === undefined) {\r\n      return null;\r\n    }\r\n\r\n    // -- 1st resize the datagrid size at first load (we need this because the .on event is not triggered on first load)\r\n    this.resizeGrid();\r\n\r\n    // -- 2nd attach a trigger on the Window DOM element, so that it happens also when resizing after first load\r\n    // -- attach auto-resize to Window object only if it exist\r\n    $(window).on('resize.grid', () => {\r\n      // for some yet unknown reason, calling the resize twice removes any stuttering/flickering when changing the height and makes it much smoother\r\n      this.resizeGrid();\r\n      this.resizeGrid();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Calculate the datagrid new height/width from the available space, also consider that a % factor might be applied to calculation\r\n   * object gridOptions\r\n   */\r\n  calculateGridNewDimensions(gridOptions: GridOption): any {\r\n    const gridDomElm = $(`#${gridOptions.gridId}`);\r\n    const containerElm = (gridOptions.autoResize && gridOptions.autoResize.containerId) ? $(`#${gridOptions.autoResize.containerId}`) : $(`#${gridOptions.gridContainerId}`);\r\n    const windowElm = $(window);\r\n    if (windowElm === undefined || containerElm === undefined || gridDomElm === undefined) {\r\n      return null;\r\n    }\r\n\r\n    // calculate bottom padding\r\n    // if using pagination, we need to add the pagination height to this bottom padding\r\n    let bottomPadding = (gridOptions.autoResize && gridOptions.autoResize.bottomPadding) ? gridOptions.autoResize.bottomPadding : DATAGRID_BOTTOM_PADDING;\r\n    if (bottomPadding && (gridOptions.enablePagination || this._gridOptions.backendServiceApi)) {\r\n      bottomPadding += DATAGRID_PAGINATION_HEIGHT;\r\n    }\r\n\r\n    const gridHeight = windowElm.height() || 0;\r\n    const coordOffsetTop = gridDomElm.offset();\r\n    const gridOffsetTop = (coordOffsetTop !== undefined) ? coordOffsetTop.top : 0;\r\n    const availableHeight = gridHeight - gridOffsetTop - bottomPadding;\r\n    const availableWidth = containerElm.width() || 0;\r\n    const minHeight = (gridOptions.autoResize && gridOptions.autoResize.minHeight < 0) ? gridOptions.autoResize.minHeight : DATAGRID_MIN_HEIGHT;\r\n    const minWidth = (gridOptions.autoResize && gridOptions.autoResize.minWidth < 0) ? gridOptions.autoResize.minWidth : DATAGRID_MIN_WIDTH;\r\n\r\n    let newHeight = availableHeight;\r\n    let newWidth = (gridOptions.autoResize && gridOptions.autoResize.sidePadding) ? availableWidth - gridOptions.autoResize.sidePadding : availableWidth;\r\n    if (newHeight < minHeight) {\r\n      newHeight = minHeight;\r\n    }\r\n    if (newWidth < minWidth) {\r\n      newWidth = minWidth;\r\n    }\r\n\r\n    return {\r\n      height: newHeight,\r\n      width: newWidth\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Dispose function when element is destroyed\r\n   */\r\n  dispose() {\r\n    $(window).off('resize.grid');\r\n  }\r\n\r\n  /** Resize the datagrid to fit the browser height & width */\r\n  resizeGrid(delay?: number, newSizes?: { height: number, width: number }): void {\r\n    if (!this._grid || !this._gridOptions) {\r\n      throw new Error(`\r\n      Angular-Slickgrid resizer requires a valid Grid object and Grid Options defined.\r\n      You can fix this by setting your gridOption to use \"enableAutoResize\" or create an instance of the ResizerService by calling attachAutoResizeDataGrid()`);\r\n    }\r\n\r\n    // because of the javascript async nature, we might want to delay the resize a little bit\r\n    delay = delay || 0;\r\n\r\n    clearTimeout(timer);\r\n    timer = setTimeout(() => {\r\n      // calculate new available sizes but with minimum height of 220px\r\n      newSizes = newSizes || this.calculateGridNewDimensions(this._gridOptions);\r\n      const gridElm = $(`#${this._gridOptions.gridId}`) || {};\r\n      const gridContainerElm = $(`#${this._gridOptions.gridContainerId}`) || {};\r\n\r\n      if (newSizes && gridElm.length > 0) {\r\n        // apply these new height/width to the datagrid\r\n        gridElm.height(newSizes.height);\r\n        gridElm.width(newSizes.width);\r\n        gridContainerElm.height(newSizes.height);\r\n        gridContainerElm.width(newSizes.width);\r\n\r\n        // resize the slickgrid canvas on all browser except some IE versions\r\n        // exclude all IE below IE11\r\n        // IE11 wants to be a better standard (W3C) follower (finally) they even changed their appName output to also have 'Netscape'\r\n        if (new RegExp('MSIE [6-8]').exec(navigator.userAgent) === null && this._grid) {\r\n          this._grid.resizeCanvas();\r\n        }\r\n\r\n        // also call the grid auto-size columns so that it takes available when going bigger\r\n        this._grid.autosizeColumns();\r\n      }\r\n    }, delay);\r\n  }\r\n}\r\n",
    "import { Sorter } from './../models/index';\r\nimport * as moment_ from 'moment-mini';\r\nconst moment = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\n\r\nexport const dateSorter: Sorter = (value1, value2, sortDirection) => {\r\n  if (!moment(value1, moment.ISO_8601).isValid() || !moment(value2, moment.ISO_8601, true).isValid()) {\r\n    return 0;\r\n  }\r\n  const date1 = moment(value1);\r\n  const date2 = moment(value2);\r\n  const diff = parseInt(date1.format('X'), 10) - parseInt(date2.format('X'), 10);\r\n\r\n  return sortDirection * (diff === 0 ? 0 : (diff > 0 ? 1 : -1));\r\n};\r\n",
    "import { mapMomentDateFormatWithFieldType } from './../services/utilities';\r\nimport { FieldType, Sorter } from './../models/index';\r\nimport * as moment_ from 'moment-mini';\r\nconst moment = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\nconst FORMAT = mapMomentDateFormatWithFieldType(FieldType.dateIso);\r\n\r\nexport const dateIsoSorter: Sorter = (value1, value2, sortDirection) => {\r\n  if (!moment(value1, FORMAT, true).isValid() || !moment(value2, FORMAT, true).isValid()) {\r\n    return 0;\r\n  }\r\n  const date1 = moment(value1, FORMAT, true);\r\n  const date2 = moment(value2, FORMAT, true);\r\n  const diff = parseInt(date1.format('X'), 10) - parseInt(date2.format('X'), 10);\r\n\r\n  return sortDirection * (diff === 0 ? 0 : (diff > 0 ? 1 : -1));\r\n};\r\n",
    "import { mapMomentDateFormatWithFieldType } from './../services/utilities';\r\nimport { FieldType, Sorter } from './../models/index';\r\nimport * as moment_ from 'moment-mini';\r\nconst moment = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\nconst FORMAT = mapMomentDateFormatWithFieldType(FieldType.dateUs);\r\n\r\nexport const dateUsSorter: Sorter = (value1, value2, sortDirection) => {\r\n  if (!moment(value1, FORMAT, true).isValid() || !moment(value2, FORMAT, true).isValid()) {\r\n    return 0;\r\n  }\r\n  const date1 = moment(value1, FORMAT, true);\r\n  const date2 = moment(value2, FORMAT, true);\r\n  const diff = parseInt(date1.format('X'), 10) - parseInt(date2.format('X'), 10);\r\n\r\n  return sortDirection * (diff === 0 ? 0 : (diff > 0 ? 1 : -1));\r\n};\r\n",
    "import { Sorter } from './../models/index';\r\n\r\nexport const numericSorter: Sorter = (value1, value2, sortDirection) => {\r\n  const x = (isNaN(value1) || value1 === '' || value1 === null) ? -99e+10 : parseFloat(value1);\r\n  const y = (isNaN(value2) || value2 === '' || value2 === null) ? -99e+10 : parseFloat(value2);\r\n  return sortDirection * (x === y ? 0 : (x > y ? 1 : -1));\r\n};\r\n",
    "import { Sorter } from './../models/index';\r\n\r\nexport const stringSorter: Sorter = (value1, value2, sortDirection) => {\r\n  let position;\r\n  if (value1 === null) {\r\n    position = -1;\r\n  } else if (value2 === null) {\r\n    position = 1;\r\n  } else if (value1 === value2) {\r\n    position = 0;\r\n  } else if (sortDirection) {\r\n    position = value1 < value2 ? -1 : 1;\r\n  } else if (!sortDirection) {\r\n    position = value1 < value2 ? 1 : -1;\r\n  }\r\n  return sortDirection * position;\r\n};\r\n",
    "import { dateUsShortSorter } from './dateUsShortSorter';\r\nimport { dateSorter } from './dateSorter';\r\nimport { dateIsoSorter } from './dateIsoSorter';\r\nimport { dateUsSorter } from './dateUsSorter';\r\nimport { numericSorter } from './numericSorter';\r\nimport { stringSorter } from './stringSorter';\r\n\r\nexport const Sorters = {\r\n  date: dateSorter,\r\n  dateIso: dateIsoSorter,\r\n  dateUs: dateUsSorter,\r\n  dateUsShort: dateUsShortSorter,\r\n  numeric: numericSorter,\r\n  string: stringSorter\r\n};\r\n",
    "import { EventEmitter } from '@angular/core';\r\nimport { castToPromise } from './utilities';\r\nimport { Column, FieldType, GridOption, SlickEvent, SortChanged, SortDirection, CurrentSorter, CellArgs, SortDirectionString } from './../models/index';\r\nimport { Sorters } from './../sorters';\r\n\r\n// using external non-typed js libraries\r\ndeclare var Slick: any;\r\n\r\nexport class SortService {\r\n  private _currentLocalSorters: CurrentSorter[] = [];\r\n  private _eventHandler: any = new Slick.EventHandler();\r\n  private _subscriber: SlickEvent = new Slick.Event();\r\n  onSortChanged = new EventEmitter<string>();\r\n\r\n  /**\r\n   * Attach a backend sort (single/multi) hook to the grid\r\n   * @param grid SlickGrid Grid object\r\n   * @param gridOptions Grid Options object\r\n   */\r\n  attachBackendOnSort(grid: any, gridOptions: GridOption) {\r\n    this._subscriber = grid.onSort;\r\n    this.emitSortChangedBy('remote');\r\n    this._subscriber.subscribe(this.attachBackendOnSortSubscribe);\r\n  }\r\n\r\n  async attachBackendOnSortSubscribe(event, args) {\r\n    if (!args || !args.grid) {\r\n      throw new Error('Something went wrong when trying to attach the \"attachBackendOnSortSubscribe(event, args)\" function, it seems that \"args\" is not populated correctly');\r\n    }\r\n    const gridOptions: GridOption = args.grid.getOptions() || {};\r\n    const backendApi = gridOptions.backendServiceApi || gridOptions.onBackendEventApi;\r\n\r\n    if (!backendApi || !backendApi.process || !backendApi.service) {\r\n      throw new Error(`BackendServiceApi requires at least a \"process\" function and a \"service\" defined`);\r\n    }\r\n    if (backendApi.preProcess) {\r\n      backendApi.preProcess();\r\n    }\r\n    const query = backendApi.service.onSortChanged(event, args);\r\n\r\n    // the process could be an Observable (like HttpClient) or a Promise\r\n    // in any case, we need to have a Promise so that we can await on it (if an Observable, convert it to Promise)\r\n    const observableOrPromise = backendApi.process(query);\r\n    const processResult = await castToPromise(observableOrPromise);\r\n\r\n    // from the result, call our internal post process to update the Dataset and Pagination info\r\n    if (processResult && backendApi.internalPostProcess) {\r\n      backendApi.internalPostProcess(processResult);\r\n    }\r\n\r\n    // send the response process to the postProcess callback\r\n    if (backendApi.postProcess) {\r\n      backendApi.postProcess(processResult);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attach a local sort (single/multi) hook to the grid\r\n   * @param grid SlickGrid Grid object\r\n   * @param gridOptions Grid Options object\r\n   * @param dataView\r\n   */\r\n  attachLocalOnSort(grid: any, gridOptions: GridOption, dataView: any, columnDefinitions: Column[]) {\r\n    this._subscriber = grid.onSort;\r\n    this.emitSortChangedBy('local');\r\n    this._subscriber.subscribe((e: any, args: any) => {\r\n      // multiSort and singleSort are not exactly the same, but we want to structure it the same for the (for loop) after\r\n      // also to avoid having to rewrite the for loop in the sort, we will make the singleSort an array of 1 object\r\n      const sortColumns = (args.multiColumnSort) ? args.sortCols : new Array({sortAsc: args.sortAsc, sortCol: args.sortCol});\r\n\r\n      // keep current sorters\r\n      this._currentLocalSorters = []; // reset current local sorters\r\n      if (Array.isArray(sortColumns)) {\r\n        sortColumns.forEach((sortColumn) => {\r\n          if (sortColumn.sortCol) {\r\n            this._currentLocalSorters.push({\r\n              columnId: sortColumn.sortCol.id,\r\n              direction: sortColumn.sortAsc ? SortDirection.ASC : SortDirection.DESC\r\n            });\r\n          }\r\n        });\r\n      }\r\n\r\n      this.onLocalSortChanged(grid, gridOptions, dataView, sortColumns);\r\n    });\r\n\r\n    this._eventHandler.subscribe(dataView.onRowCountChanged, (e: Event, args: any) => {\r\n      // load any presets if there are any\r\n      if (args.current > 0) {\r\n        this.loadLocalPresets(grid, gridOptions, dataView, columnDefinitions);\r\n      }\r\n    });\r\n  }\r\n\r\n  getCurrentLocalSorters(): CurrentSorter[] {\r\n    return this._currentLocalSorters;\r\n  }\r\n\r\n  /**\r\n   * load any presets if there are any\r\n   * @param grid\r\n   * @param gridOptions\r\n   * @param dataView\r\n   * @param columnDefinitions\r\n   */\r\n  loadLocalPresets(grid: any, gridOptions: GridOption, dataView: any, columnDefinitions: Column[]) {\r\n    const sortCols: SortChanged[] = [];\r\n    this._currentLocalSorters = []; // reset current local sorters\r\n    if (gridOptions && gridOptions.presets && gridOptions.presets.sorters) {\r\n      const sorters = gridOptions.presets.sorters;\r\n      columnDefinitions.forEach((columnDef: Column) =>  {\r\n        const columnPreset = sorters.find((currentSorter: CurrentSorter) => {\r\n          return currentSorter.columnId === columnDef.id;\r\n        });\r\n        if (columnPreset) {\r\n          sortCols.push({\r\n            columnId: columnDef.id,\r\n            sortAsc: ((columnPreset.direction.toUpperCase() === SortDirection.ASC) ? true : false),\r\n            sortCol: columnDef\r\n          });\r\n\r\n          // keep current sorters\r\n          this._currentLocalSorters.push({\r\n            columnId: columnDef.id + '',\r\n            direction: columnPreset.direction.toUpperCase() as SortDirectionString\r\n          });\r\n        }\r\n      });\r\n\r\n      if (sortCols.length > 0) {\r\n        this.onLocalSortChanged(grid, gridOptions, dataView, sortCols);\r\n        grid.setSortColumns(sortCols);\r\n      }\r\n    }\r\n  }\r\n\r\n  onLocalSortChanged(grid: any, gridOptions: GridOption, dataView: any, sortColumns: SortChanged[]) {\r\n    dataView.sort((dataRow1: any, dataRow2: any) => {\r\n      for (let i = 0, l = sortColumns.length; i < l; i++) {\r\n        const columnSortObj = sortColumns[i];\r\n        if (columnSortObj && columnSortObj.sortCol) {\r\n          const sortDirection = columnSortObj.sortAsc ? 1 : -1;\r\n          const sortField = columnSortObj.sortCol.queryField || columnSortObj.sortCol.field;\r\n          const fieldType = columnSortObj.sortCol.type || 'string';\r\n          const value1 = dataRow1[sortField];\r\n          const value2 = dataRow2[sortField];\r\n          let result = 0;\r\n\r\n          switch (fieldType) {\r\n            case FieldType.number:\r\n              result = Sorters.numeric(value1, value2, sortDirection);\r\n              break;\r\n            case FieldType.date:\r\n              result = Sorters.date(value1, value2, sortDirection);\r\n              break;\r\n            case FieldType.dateIso:\r\n              result = Sorters.dateIso(value1, value2, sortDirection);\r\n              break;\r\n            case FieldType.dateUs:\r\n              result = Sorters.dateUs(value1, value2, sortDirection);\r\n              break;\r\n            case FieldType.dateUsShort:\r\n              result = Sorters.dateUsShort(value1, value2, sortDirection);\r\n              break;\r\n            default:\r\n              result = Sorters.string(value1, value2, sortDirection);\r\n              break;\r\n          }\r\n\r\n          if (result !== 0) {\r\n            return result;\r\n          }\r\n        }\r\n      }\r\n      return 0;\r\n    });\r\n    grid.invalidate();\r\n    grid.render();\r\n  }\r\n\r\n  dispose() {\r\n    // unsubscribe local event\r\n    if (this._subscriber && typeof this._subscriber.unsubscribe === 'function') {\r\n      this._subscriber.unsubscribe();\r\n    }\r\n\r\n    // unsubscribe all SlickGrid events\r\n    this._eventHandler.unsubscribeAll();\r\n  }\r\n\r\n  /**\r\n   * A simple function that is attached to the subscriber and emit a change when the sort is called.\r\n   * Other services, like Pagination, can then subscribe to it.\r\n   * @param sender\r\n   */\r\n  emitSortChangedBy(sender: string) {\r\n    this._subscriber.subscribe(() => this.onSortChanged.emit(`onSortChanged by ${sender}`));\r\n  }\r\n}\r\n",
    "import { mapFlatpickrDateFormatWithFieldType } from './../services/utilities';\r\nimport { Column, Editor, FieldType, GridOption } from './../models/index';\r\nimport { TranslateService } from '@ngx-translate/core';\r\nimport $ from 'jquery';\r\n\r\ndeclare function require(name: string);\r\nrequire('flatpickr');\r\n\r\n// using external non-typed js libraries\r\ndeclare var $: any;\r\n\r\n/*\r\n * An example of a date picker editor using Flatpickr\r\n * https://chmln.github.io/flatpickr\r\n */\r\nexport class DateEditor implements Editor {\r\n  $input: any;\r\n  flatInstance: any;\r\n  defaultDate: string;\r\n\r\n  constructor(private args: any) {\r\n    this.init();\r\n  }\r\n\r\n  init(): void {\r\n    const gridOptions = this.args.grid.getOptions() as GridOption;\r\n    this.defaultDate = this.args.item[this.args.column.field] || null;\r\n    const inputFormat = mapFlatpickrDateFormatWithFieldType(this.args.column.type || FieldType.dateIso);\r\n    const outputFormat = mapFlatpickrDateFormatWithFieldType(this.args.column.outputType || FieldType.dateUtc);\r\n    const currentLocale = this.getCurrentLocale(this.args.column, gridOptions);\r\n\r\n    const pickerOptions: any = {\r\n      defaultDate: this.defaultDate,\r\n      altInput: true,\r\n      altFormat: inputFormat,\r\n      dateFormat: outputFormat,\r\n      closeOnSelect: false,\r\n      locale: (currentLocale !== 'en') ? this.loadFlatpickrLocale(currentLocale) : 'en',\r\n      onChange: (selectedDates, dateStr, instance) => {\r\n        this.save();\r\n      },\r\n    };\r\n\r\n\r\n    this.$input = $(`<input type=\"text\" data-defaultDate=\"${this.defaultDate}\" class=\"editor-text flatpickr\" />`);\r\n    this.$input.appendTo(this.args.container);\r\n    this.flatInstance = (this.$input[0] && typeof this.$input[0].flatpickr === 'function') ? this.$input[0].flatpickr(pickerOptions) : null;\r\n    this.show();\r\n  }\r\n\r\n  getCurrentLocale(columnDef: Column, gridOptions: GridOption) {\r\n    const params = columnDef.params || {};\r\n    if (params.i18n && params.i18n instanceof TranslateService) {\r\n      return params.i18n.currentLang;\r\n    }\r\n\r\n    return 'en';\r\n  }\r\n\r\n  loadFlatpickrLocale(locale: string) {\r\n    // change locale if needed, Flatpickr reference: https://chmln.github.io/flatpickr/localization/\r\n    if (locale !== 'en') {\r\n      const localeDefault: any = require(`flatpickr/dist/l10n/${locale}.js`).default;\r\n      return (localeDefault && localeDefault[locale]) ? localeDefault[locale] : 'en';\r\n    }\r\n    return 'en';\r\n  }\r\n\r\n  destroy() {\r\n    this.hide();\r\n    // this.flatInstance.destroy();\r\n    this.$input.remove();\r\n  }\r\n\r\n  show() {\r\n    if (this.flatInstance && typeof this.flatInstance.open === 'function') {\r\n      this.flatInstance.open();\r\n    }\r\n  }\r\n\r\n  hide() {\r\n    if (this.flatInstance && typeof this.flatInstance.close === 'function') {\r\n      this.flatInstance.close();\r\n    }\r\n  }\r\n\r\n  focus() {\r\n    this.$input.focus();\r\n  }\r\n\r\n  save() {\r\n    this.args.commitChanges();\r\n  }\r\n\r\n  loadValue(item: any) {\r\n    this.defaultDate = item[this.args.column.field];\r\n  }\r\n\r\n  serializeValue() {\r\n    return this.$input.val();\r\n  }\r\n\r\n  applyValue(item: any, state: any) {\r\n    item[this.args.column.field] = state;\r\n  }\r\n\r\n  isValueChanged() {\r\n    return (!(this.$input.val() === '' && this.defaultDate == null)) && (this.$input.val() !== this.defaultDate);\r\n  }\r\n\r\n  validate() {\r\n    if (this.args.column.validator) {\r\n      const validationResults = this.args.column.validator(this.$input.val(), this.args);\r\n      if (!validationResults.valid) {\r\n        return validationResults;\r\n      }\r\n    }\r\n\r\n    return {\r\n      valid: true,\r\n      msg: null\r\n    };\r\n  }\r\n}\r\n",
    "import $ from 'jquery';\r\nimport { Editor } from './../models/index';\r\n\r\n// using external non-typed js libraries\r\ndeclare var $: any;\r\n\r\n/*\r\n * An example of a 'detached' editor.\r\n * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.\r\n */\r\nexport class CheckboxEditor implements Editor {\r\n  $input: any;\r\n  defaultValue: boolean;\r\n\r\n  constructor(private args: any) {\r\n    this.init();\r\n  }\r\n\r\n  init(): void {\r\n    this.$input = $(`<input type=\"checkbox\" value=\"true\" class=\"editor-checkbox\" />`);\r\n    this.$input.appendTo(this.args.container);\r\n    this.$input.focus();\r\n  }\r\n\r\n  destroy(): void {\r\n    this.$input.remove();\r\n  }\r\n\r\n  focus(): void {\r\n    this.$input.focus();\r\n  }\r\n\r\n  hide() {\r\n    this.$input.hide();\r\n  }\r\n\r\n  show() {\r\n    this.$input.show();\r\n  }\r\n\r\n  loadValue(item: any) {\r\n    this.defaultValue = !!item[this.args.column.field];\r\n    if (this.defaultValue) {\r\n      this.$input.prop('checked', true);\r\n    } else {\r\n      this.$input.prop('checked', false);\r\n    }\r\n  }\r\n\r\n  preClick() {\r\n    this.$input.prop('checked', !this.$input.prop('checked'));\r\n  }\r\n\r\n  serializeValue(): boolean {\r\n    return this.$input.prop('checked');\r\n  }\r\n\r\n  applyValue(item: any, state: any) {\r\n    item[this.args.column.field] = state;\r\n  }\r\n\r\n  isValueChanged() {\r\n    return (this.serializeValue() !== this.defaultValue);\r\n  }\r\n\r\n  validate() {\r\n    return {\r\n      valid: true,\r\n      msg: null\r\n    };\r\n  }\r\n}\r\n",
    "import $ from 'jquery';\r\nimport { Editor, KeyCode } from './../models/index';\r\n\r\n// using external non-typed js libraries\r\ndeclare var $: any;\r\n\r\n/*\r\n * An example of a 'detached' editor.\r\n * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.\r\n */\r\nexport class IntegerEditor implements Editor {\r\n  $input: any;\r\n  defaultValue: any;\r\n\r\n  constructor(private args: any) {\r\n    this.init();\r\n  }\r\n\r\n  init(): void {\r\n    this.$input = $(`<input type=\"text\" class='editor-text' />`)\r\n      .appendTo(this.args.container)\r\n      .on('keydown.nav', (e) => {\r\n        if (e.keyCode === KeyCode.LEFT || e.keyCode === KeyCode.RIGHT) {\r\n          e.stopImmediatePropagation();\r\n        }\r\n      })\r\n      .focus()\r\n      .select();\r\n  }\r\n\r\n  destroy() {\r\n    this.$input.remove();\r\n  }\r\n\r\n  focus() {\r\n    this.$input.focus();\r\n  }\r\n\r\n  loadValue(item: any) {\r\n    this.defaultValue = item[this.args.column.field];\r\n    this.$input.val(this.defaultValue);\r\n    this.$input[0].defaultValue = this.defaultValue;\r\n    this.$input.select();\r\n  }\r\n\r\n  serializeValue() {\r\n    return parseInt(this.$input.val() as string, 10) || 0;\r\n  }\r\n\r\n  applyValue(item: any, state: any) {\r\n    item[this.args.column.field] = state;\r\n  }\r\n\r\n  isValueChanged() {\r\n    return (!(this.$input.val() === '' && this.defaultValue === null)) && (this.$input.val() !== this.defaultValue);\r\n  }\r\n\r\n  validate() {\r\n    if (isNaN(this.$input.val() as number)) {\r\n      return {\r\n        valid: false,\r\n        msg: 'Please enter a valid integer'\r\n      };\r\n    }\r\n\r\n    if (this.args.column.validator) {\r\n      const validationResults = this.args.column.validator(this.$input.val());\r\n      if (!validationResults.valid) {\r\n        return validationResults;\r\n      }\r\n    }\r\n\r\n    return {\r\n      valid: true,\r\n      msg: null\r\n    };\r\n  }\r\n}\r\n",
    "import $ from 'jquery';\r\nimport { Editor, KeyCode } from './../models/index';\r\n\r\n// using external non-typed js libraries\r\ndeclare var $: any;\r\n\r\nconst defaultDecimalPlaces = 0;\r\n\r\n/*\r\n * An example of a 'detached' editor.\r\n * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.\r\n */\r\nexport class FloatEditor implements Editor {\r\n  $input: any;\r\n  defaultValue: any;\r\n\r\n  constructor(private args: any) {\r\n    this.init();\r\n  }\r\n\r\n  init(): void {\r\n    this.$input = $(`<input type=\"text\" class='editor-text' />`)\r\n      .appendTo(this.args.container)\r\n      .on('keydown.nav', (e) => {\r\n        if (e.keyCode === KeyCode.LEFT || e.keyCode === KeyCode.RIGHT) {\r\n          e.stopImmediatePropagation();\r\n        }\r\n      })\r\n      .focus()\r\n      .select();\r\n  }\r\n\r\n  destroy() {\r\n    this.$input.remove();\r\n  }\r\n\r\n  focus() {\r\n    this.$input.focus();\r\n  }\r\n\r\n  getDecimalPlaces() {\r\n    // returns the number of fixed decimal places or null\r\n    let rtn = this.args.column.editorFixedDecimalPlaces;\r\n    if (rtn === undefined) {\r\n      rtn = defaultDecimalPlaces;\r\n    }\r\n    return (!rtn && rtn !== 0 ? null : rtn);\r\n  }\r\n\r\n  loadValue(item: any) {\r\n    this.defaultValue = item[this.args.column.field];\r\n\r\n    const decPlaces = this.getDecimalPlaces();\r\n    if (decPlaces !== null\r\n      && (this.defaultValue || this.defaultValue === 0)\r\n      && this.defaultValue.toFixed) {\r\n      this.defaultValue = this.defaultValue.toFixed(decPlaces);\r\n    }\r\n\r\n    this.$input.val(this.defaultValue);\r\n    this.$input[0].defaultValue = this.defaultValue;\r\n    this.$input.select();\r\n  }\r\n\r\n  serializeValue() {\r\n    let rtn = parseFloat(this.$input.val()) || 0;\r\n    const decPlaces = this.getDecimalPlaces();\r\n    if (decPlaces !== null\r\n      && (rtn || rtn === 0)\r\n      && rtn.toFixed) {\r\n      rtn = parseFloat(rtn.toFixed(decPlaces));\r\n    }\r\n\r\n    return rtn;\r\n  }\r\n\r\n  applyValue(item: any, state: any) {\r\n    item[this.args.column.field] = state;\r\n  }\r\n\r\n  isValueChanged() {\r\n    return (!(this.$input.val() === '' && this.defaultValue === null)) && (this.$input.val() !== this.defaultValue);\r\n  }\r\n\r\n  validate() {\r\n    if (isNaN(this.$input.val())) {\r\n      return {\r\n        valid: false,\r\n        msg: 'Please enter a valid number'\r\n      };\r\n    }\r\n\r\n    if (this.args.column.validator) {\r\n      const validationResults = this.args.column.validator(this.$input.val());\r\n      if (!validationResults.valid) {\r\n        return validationResults;\r\n      }\r\n    }\r\n\r\n    return {\r\n      valid: true,\r\n      msg: null\r\n    };\r\n  }\r\n}\r\n",
    "import $ from 'jquery';\r\nimport { Editor, HtmlElementPosition, KeyCode } from './../models/index';\r\n\r\n// using external non-typed js libraries\r\ndeclare var $: any;\r\n\r\n/*\r\n * An example of a 'detached' editor.\r\n * The UI is added onto document BODY and .position(), .show() and .hide() are implemented.\r\n * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.\r\n */\r\nexport class LongTextEditor implements Editor {\r\n  $input: any;\r\n  $wrapper: any;\r\n  defaultValue: any;\r\n\r\n  constructor(private args: any) {\r\n    this.init();\r\n  }\r\n\r\n  init(): void {\r\n    const $container = $('body');\r\n\r\n    this.$wrapper = $(`<div class=\"slick-large-editor-text\" />`).appendTo($container);\r\n    this.$input = $(`<textarea hidefocus rows=\"5\">`).appendTo(this.$wrapper);\r\n\r\n    $(`<div class=\"editor-footer\">\r\n        <button class=\"btn btn-primary btn-xs\">Save</button>\r\n        <button class=\"btn btn-default btn-xs\">Cancel</button>\r\n      </div>`).appendTo(this.$wrapper);\r\n\r\n    this.$wrapper.find('button:first').on('click', (event: Event) => this.save());\r\n    this.$wrapper.find('button:last').on('click', (event: Event) => this.cancel());\r\n    this.$input.on('keydown', this.handleKeyDown);\r\n\r\n    this.position(this.args.position);\r\n    this.$input.focus().select();\r\n  }\r\n\r\n  handleKeyDown(e: any) {\r\n    if (e.which === KeyCode.ENTER && e.ctrlKey) {\r\n      this.save();\r\n    } else if (e.which === KeyCode.ESCAPE) {\r\n      e.preventDefault();\r\n      this.cancel();\r\n    } else if (e.which === KeyCode.TAB && e.shiftKey) {\r\n      e.preventDefault();\r\n      this.args.grid.navigatePrev();\r\n    } else if (e.which === KeyCode.TAB) {\r\n      e.preventDefault();\r\n      this.args.grid.navigateNext();\r\n    }\r\n  }\r\n\r\n  save() {\r\n    this.args.commitChanges();\r\n  }\r\n\r\n  cancel() {\r\n    this.$input.val(this.defaultValue);\r\n    this.args.cancelChanges();\r\n  }\r\n\r\n  hide() {\r\n    this.$wrapper.hide();\r\n  }\r\n\r\n  show() {\r\n    this.$wrapper.show();\r\n  }\r\n\r\n  position(position: HtmlElementPosition) {\r\n    this.$wrapper\r\n      .css('top', (position.top || 0) - 5)\r\n      .css('left', (position.left || 0) - 5);\r\n  }\r\n\r\n  destroy() {\r\n    this.$wrapper.remove();\r\n  }\r\n\r\n  focus() {\r\n    this.$input.focus();\r\n  }\r\n\r\n  loadValue(item: any) {\r\n    this.$input.val(this.defaultValue = item[this.args.column.field]);\r\n    this.$input.select();\r\n  }\r\n\r\n  serializeValue() {\r\n    return this.$input.val();\r\n  }\r\n\r\n  applyValue(item: any, state: any) {\r\n    item[this.args.column.field] = state;\r\n  }\r\n\r\n  isValueChanged() {\r\n    return (!(this.$input.val() === '' && this.defaultValue == null)) && (this.$input.val() !== this.defaultValue);\r\n  }\r\n\r\n  validate() {\r\n    let valid = true;\r\n    let msg = null;\r\n    if (this.args.column.validator) {\r\n      const validationResults = this.args.column.validator(this.$input.val(), this.args);\r\n      valid = validationResults.valid;\r\n      msg = validationResults.msg;\r\n    }\r\n\r\n    return {\r\n      valid,\r\n      msg\r\n    };\r\n  }\r\n}\r\n",
    "import $ from 'jquery';\r\nimport { Editor, KeyCode } from './../models/index';\r\n\r\n// using external non-typed js libraries\r\ndeclare var $: any;\r\n\r\n/*\r\n * An example of a 'detached' editor.\r\n * KeyDown events are also handled to provide handling for Tab, Shift-Tab, Esc and Ctrl-Enter.\r\n */\r\nexport class TextEditor implements Editor {\r\n  $input: any;\r\n  defaultValue: any;\r\n\r\n  constructor(private args: any) {\r\n    this.init();\r\n  }\r\n\r\n  init(): void {\r\n    this.$input = $(`<input type=\"text\" class='editor-text' />`)\r\n      .appendTo(this.args.container)\r\n      .on('keydown.nav', (e) => {\r\n        if (e.keyCode === KeyCode.LEFT || e.keyCode === KeyCode.RIGHT) {\r\n          e.stopImmediatePropagation();\r\n        }\r\n      })\r\n      .focus()\r\n      .select();\r\n  }\r\n\r\n  destroy() {\r\n    this.$input.remove();\r\n  }\r\n\r\n  focus() {\r\n    this.$input.focus();\r\n  }\r\n\r\n  getValue() {\r\n    return this.$input.val();\r\n  }\r\n\r\n  setValue(val: string) {\r\n    this.$input.val(val);\r\n  }\r\n\r\n  loadValue(item: any) {\r\n    this.defaultValue = item[this.args.column.field] || '';\r\n    this.$input.val(this.defaultValue);\r\n    this.$input[0].defaultValue = this.defaultValue;\r\n    this.$input.select();\r\n  }\r\n\r\n  serializeValue() {\r\n    return this.$input.val();\r\n  }\r\n\r\n  applyValue(item: any, state: any) {\r\n    item[this.args.column.field] = state;\r\n  }\r\n\r\n  isValueChanged() {\r\n    return (!(this.$input.val() === '' && this.defaultValue === null)) && (this.$input.val() !== this.defaultValue);\r\n  }\r\n\r\n  validate() {\r\n    if (this.args.column.validator) {\r\n      const validationResults = this.args.column.validator(this.$input.val());\r\n      if (!validationResults.valid) {\r\n        return validationResults;\r\n      }\r\n    }\r\n\r\n    return {\r\n      valid: true,\r\n      msg: null\r\n    };\r\n  }\r\n}\r\n",
    "import { CheckboxEditor } from './checkboxEditor';\nimport { DateEditor } from './dateEditor';\nimport { FloatEditor } from './floatEditor';\nimport { IntegerEditor } from './integerEditor';\nimport { LongTextEditor } from './longTextEditor';\nimport { TextEditor } from './textEditor';\n\nexport const Editors = {\n  checkbox: CheckboxEditor,\n  date: DateEditor,\n  float: FloatEditor,\n  integer: IntegerEditor,\n  longText: LongTextEditor,\n  text: TextEditor\n};\n",
    "import { Column } from './../models/column.interface';\nimport { Formatter } from './../models/formatter.interface';\n\nexport const arrayToCsvFormatter: Formatter = (row: number, cell: number, value: any, columnDef: Column, dataContext: any) => {\n  if (value && Array.isArray(value)) {\n    return value.join(', ');\n  }\n  return '';\n};\n",
    "import { Column } from './../models/column.interface';\nimport { Formatter } from './../models/formatter.interface';\n\nexport const checkmarkFormatter: Formatter = (row: number, cell: number, value: any, columnDef: Column, dataContext: any) =>\n  value ? `<i class=\"fa fa-check checkmark-icon\" aria-hidden=\"true\"></i>` : '';\n",
    "import { Column } from './../models/column.interface';\nimport { Formatter } from './../models/formatter.interface';\n\nexport const lowercaseFormatter: Formatter = (row: number, cell: number, value: string | any, columnDef: Column, dataContext: any): string => {\n  // make sure the value is a string\n  if (value !== undefined && typeof value !== 'string') {\n    value = value + '';\n  }\n\n  return value ? value.toLowerCase() : '';\n};\n",
    "import { Column } from './../models/column.interface';\nimport { Formatter } from './../models/formatter.interface';\n\nexport const complexObjectFormatter: Formatter = (row: number, cell: number, value: any, columnDef: Column, dataContext: any) => {\n  if (!columnDef) {\n    return '';\n  }\n  const complexField = columnDef.field || '';\n  return complexField.split('.').reduce((obj, i) => obj[i], dataContext);\n};\n",
    "import { Column, FieldType, Formatter } from './../models/index';\r\nimport { mapMomentDateFormatWithFieldType } from './../services/utilities';\r\nimport * as moment_ from 'moment-mini';\r\nconst moment = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\nconst FORMAT = mapMomentDateFormatWithFieldType(FieldType.dateTimeIsoAmPm);\r\n\r\nexport const dateTimeIsoAmPmFormatter: Formatter = (row: number, cell: number, value: any, columnDef: Column, dataContext: any) =>\r\n  value ? moment(value).format(FORMAT) : '';\r\n",
    "import { Column, FieldType, Formatter } from './../models/index';\r\nimport { mapMomentDateFormatWithFieldType } from './../services/utilities';\r\nimport * as moment_ from 'moment-mini';\r\nconst moment = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\nconst FORMAT = mapMomentDateFormatWithFieldType(FieldType.dateTimeUsAmPm);\r\n\r\nexport const dateTimeUsAmPmFormatter: Formatter = (row: number, cell: number, value: any, columnDef: Column, dataContext: any) =>\r\n  value ? moment(value).format(FORMAT) : '';\r\n",
    "import { Column, FieldType, Formatter } from './../models/index';\r\nimport { mapMomentDateFormatWithFieldType } from './../services/utilities';\r\nimport * as moment_ from 'moment-mini';\r\nconst moment = moment_; // patch to fix rollup \"moment has no default export\" issue, document here https://github.com/rollup/rollup/issues/670\r\nconst FORMAT = mapMomentDateFormatWithFieldType(FieldType.dateUs);\r\n\r\nexport const dateUsFormatter: Formatter = (row: number, cell: number, value: any, columnDef: Column, dataContext: any) =>\r\n  value ? moment(value).format(FORMAT) : '';\r\n",
    "import { Column } from './../models/column.interface';\nimport { Formatter } from './../models/formatter.interface';\n\nexport const editIconFormatter: Formatter = (row: number, cell: number, value: any, columnDef: Column, dataContext: any) =>\n  `<i class=\"fa fa-pencil pointer edit-icon\" aria-hidden=\"true\"></i>`;\n",
    "import { Column } from './../models/column.interface';\nimport { Formatter } from './../models/formatter.interface';\n\nexport const hyperlinkFormatter: Formatter = (row: number, cell: number, value: any, columnDef: Column, dataContext: any) => {\n  const matchUrl = value.match(/^(http|ftp|https):\\/\\/[\\w\\-_]+(\\.[\\w\\-_]+)+([\\w\\-\\.,@?^=%&amp;:\\/~\\+#]*[\\w\\-\\@?^=%&amp;\\/~\\+#])?/, 'i');\n  if (matchUrl && Array.isArray(matchUrl)) {\n    return `<a href=\"${matchUrl[0]}\">' + value + '</a>`;\n  }\n  return '';\n};\n",
    "import { Column, Formatter } from './../models/index';\r\n\r\nexport const multipleFormatter: Formatter = (row: number, cell: number, value: any, columnDef: Column, dataContext: any) => {\r\n  const params = columnDef.params || {};\r\n  if (!params.formatters || !Array.isArray(params.formatters)) {\r\n    throw new Error(`The multiple formatter requires the \"formatters\" to be provided as a column params.\r\n    For example: this.columnDefinitions = [{ id: title, field: title, formatter: Formatters.multiple, params: { formatters: [Formatters.lowercase, Formatters.uppercase] }`);\r\n  }\r\n  const formatters: Formatter[] = params.formatters;\r\n  let formattedValue = '';\r\n  for (const formatter of formatters) {\r\n    formattedValue = formatter(row, cell, value, columnDef, dataContext);\r\n  }\r\n  return formattedValue;\r\n};\r\n",
    "import { Column } from './../models/column.interface';\nimport { Formatter } from './../models/formatter.interface';\n\nexport const percentCompleteFormatter: Formatter = (row: number, cell: number, value: any, columnDef: Column, dataContext: any): string => {\n  if (value === null || value === '') {\n    return '-';\n  } else if (value < 50) {\n    return `<span style='color:red;font-weight:bold;'>${value}%</span>`;\n  } else {\n    return `<span style='color:green'>${value}%</span>`;\n  }\n};\n",
    "import { Column } from './../models/column.interface';\nimport { Formatter } from './../models/formatter.interface';\n\nexport const percentCompleteBarFormatter: Formatter = (row: number, cell: number, value: any, columnDef: Column, dataContext: any): string => {\n  if (value === null || value === '') {\n    return '';\n  }\n\n  let color;\n\n  if (value < 30) {\n    color = 'red';\n  } else if (value < 70) {\n    color = 'silver';\n  } else {\n    color = 'green';\n  }\n\n  return `<span class=\"percent-complete-bar\" style=\"background:${color}; width:${value}%\"></span>`;\n};\n",
    "import { Column } from './../models/column.interface';\nimport { Formatter } from './../models/formatter.interface';\n\nexport const progressBarFormatter: Formatter = (row: number, cell: number, value: any, columnDef: Column, dataContext: any): string => {\n  if (value === null || value === '') {\n    return '';\n  }\n\n  let color;\n\n  if (value < 30) {\n    color = 'danger';\n  } else if (value < 70) {\n    color = 'warning';\n  } else {\n    color = 'success';\n  }\n\n  return `<div class=\"progress\">\n    <div class=\"progress-bar progress-bar-${color}\" role=\"progressbar\" aria-valuenow=\"${value}\" aria-valuemin=\"0\" aria-valuemax=\"100\" style=\"min-width: 2em; width: ${value}%;\">\n    ${value}%\n    </div>\n  </div>`;\n};\n",
    "import { Column, Formatter } from './../models/index';\nimport { TranslateService } from '@ngx-translate/core';\n\n/** Takes a cell value and translates it (i18n). Requires an instance of the Translate Service:: `params: { i18n: this.translate } */\nexport const translateFormatter: Formatter = (row: number, cell: number, value: any, columnDef: Column, dataContext: any, grid: any) => {\n  const gridOptions = (grid && typeof grid.getOptions === 'function') ? grid.getOptions() : {};\n  const columnParams = columnDef.params || {};\n  const gridParams = gridOptions.params || {};\n\n  if ((!columnParams.i18n || !(columnParams.i18n instanceof TranslateService)) && (!gridParams.i18n || !(gridParams.i18n instanceof TranslateService))) {\n    throw new Error(`The translate formatter requires the ngx-translate \"TranslateService\" to be provided as a Column Definition params or a Grid Option params.\n    For example: this.gridOptions = { enableTranslate: true, params: { i18n: this.translateService }}`);\n  }\n\n  const translate = gridParams.i18n || columnParams.i18n;\n\n  // make sure the value is a string (for example a boolean value would throw an error)\n  if (value !== undefined && typeof value !== 'string') {\n    value = value + '';\n  }\n\n  return value ? translate.instant(value) : '';\n};\n",
    "import { Column, Formatter } from './../models/index';\nimport { TranslateService } from '@ngx-translate/core';\n\n/** Takes a boolean value, cast it to upperCase string and finally translates (i18n) it */\nexport const translateBooleanFormatter: Formatter = (row: number, cell: number, value: any, columnDef: Column, dataContext: any, grid: any) => {\n  const gridOptions = (grid && typeof grid.getOptions === 'function') ? grid.getOptions() : {};\n  const columnParams = columnDef.params || {};\n  const gridParams = gridOptions.params || {};\n\n  if ((!columnParams.i18n || !(columnParams.i18n instanceof TranslateService)) && (!gridParams.i18n || !(gridParams.i18n instanceof TranslateService))) {\n    throw new Error(`The translate formatter requires the ngx-translate \"TranslateService\" to be provided as a Column Definition params or a Grid Option params.\n    For example: this.gridOptions = { enableTranslate: true, params: { i18n: this.translateService }}`);\n  }\n\n  const translate = gridParams.i18n || columnParams.i18n;\n\n  // make sure the value is a string (for example a boolean value would throw an error)\n  if (value !== undefined && typeof value !== 'string') {\n    value = value + '';\n  }\n  return value ? translate.instant(value.toUpperCase() as string) : '';\n};\n",
    "import { Column } from './../models/column.interface';\nimport { Formatter } from './../models/formatter.interface';\n\nexport const uppercaseFormatter: Formatter = (row: number, cell: number, value: string | any, columnDef: Column, dataContext: any): string => {\n  // make sure the value is a string\n  if (value !== undefined && typeof value !== 'string') {\n    value = value + '';\n  }\n\n  return value ? value.toUpperCase() : '';\n};\n",
    "import { Column } from './../models/column.interface';\nimport { Formatter } from './../models/formatter.interface';\n\nexport const yesNoFormatter: Formatter = (row: number, cell: number, value: any, columnDef: Column, dataContext: any): string =>\n  value ? 'Yes' : 'No';\n",
    "import { Column } from './../models/index';\r\n// import { Group, GroupTotals } from '../core'\r\n// import { Item } from '../dataview'\r\nimport { arrayToCsvFormatter } from './arrayToCsvFormatter';\r\nimport { checkboxFormatter } from './checkboxFormatter';\r\nimport { checkmarkFormatter } from './checkmarkFormatter';\r\nimport { complexObjectFormatter } from './complexObjectFormatter';\r\nimport { dateIsoFormatter } from './dateIsoFormatter';\r\nimport { dateTimeIsoAmPmFormatter } from './dateTimeIsoAmPmFormatter';\r\nimport { dateTimeUsAmPmFormatter } from './dateTimeUsAmPmFormatter';\r\nimport { dateTimeUsFormatter } from './dateTimeUsFormatter';\r\nimport { dateUsFormatter } from './dateUsFormatter';\r\nimport { deleteIconFormatter } from './deleteIconFormatter';\r\nimport { editIconFormatter } from './editIconFormatter';\r\nimport { hyperlinkFormatter } from './hyperlinkFormatter';\r\nimport { infoIconFormatter } from './infoIconFormatter';\r\nimport { lowercaseFormatter } from './lowercaseFormatter';\r\nimport { multipleFormatter } from './multipleFormatter';\r\nimport { percentCompleteFormatter } from './percentCompleteFormatter';\r\nimport { percentCompleteBarFormatter } from './percentCompleteBarFormatter';\r\nimport { progressBarFormatter } from './progressBarFormatter';\r\nimport { translateFormatter } from './translateFormatter';\r\nimport { translateBooleanFormatter } from './translateBooleanFormatter';\r\nimport { uppercaseFormatter } from './uppercaseFormatter';\r\nimport { yesNoFormatter } from './yesNoFormatter';\r\n\r\n/*\r\nexport interface GroupFormatter {\r\n  (row: number, cell: number, value: any, columnDef: Column, dataContext: Group): string\r\n}\r\nexport interface GroupTotalsFormatter {\r\n  (row: number, cell: number, value: any, columnDef: Column, dataContext: GroupTotals): string\r\n}\r\n*/\r\n\r\n/** Provides a list of different Formatters that will change the cell value displayed in the UI */\r\nexport const Formatters = {\r\n  /** Takes an array of string and converts it to a comma delimited string */\r\n  arrayToCsv: arrayToCsvFormatter,\r\n\r\n  /** When value is filled (true), it will display a checkbox Unicode icon */\r\n  checkbox: checkboxFormatter,\r\n\r\n  /** When value is filled (true), it will display a Font-Awesome icon (fa-check) */\r\n  checkmark: checkmarkFormatter,\r\n\r\n  /** Takes a complex data object and return the data under that property (for example: \"user.firstName\" will return the first name \"John\") */\r\n  complexObject: complexObjectFormatter,\r\n\r\n  /** Takes a Date object and displays it as an ISO Date format */\r\n  dateIso: dateIsoFormatter,\r\n\r\n  /** Takes a Date object and displays it as an ISO Date+Time format */\r\n  dateTimeIso: dateIsoFormatter,\r\n\r\n  /** Takes a Date object and displays it as an ISO Date+Time+(am/pm) format */\r\n  dateTimeIsoAmPm: dateTimeIsoAmPmFormatter,\r\n\r\n  /** Takes a Date object and displays it as an US Date format */\r\n  dateUs: dateUsFormatter,\r\n\r\n  /** Takes a Date object and displays it as an US Date+Time format */\r\n  dateTimeUs: dateTimeUsFormatter,\r\n\r\n  /** Takes a Date object and displays it as an US Date+Time+(am/pm) format */\r\n  dateTimeUsAmPm: dateTimeUsAmPmFormatter,\r\n\r\n  /** Displays a Font-Awesome delete icon (fa-trash) */\r\n  deleteIcon: deleteIconFormatter,\r\n\r\n  /** Displays a Font-Awesome edit icon (fa-pencil) */\r\n  editIcon: editIconFormatter,\r\n\r\n  /** Takes a cell value and transforms it into an hyperlink, given that the value starts with 1 of these (http|ftp|https) */\r\n  hyperlink: hyperlinkFormatter,\r\n\r\n  /** Displays a Font-Awesome edit icon (fa-info-circle) */\r\n  infoIcon: infoIconFormatter,\r\n\r\n  /** Takes a value and displays it all lowercase */\r\n  lowercase: lowercaseFormatter,\r\n\r\n  /**\r\n   * You can pipe multiple formatters (executed in sequence), use params to pass the list of formatters. For example::\r\n   * { field: 'title', formatter: Formatters.multiple, params: { formatters: [ Formatters.lowercase, Formatters.uppercase ] }\r\n   */\r\n  multiple: multipleFormatter,\r\n\r\n  /** Takes a cell value number (between 0-100) and displays a red (<50) or green (>=50) bar */\r\n  percentComplete: percentCompleteFormatter,\r\n\r\n  /** Takes a cell value number (between 0-100) and displays Bootstrap \"percent-complete-bar\" a red (<30), silver (>30 & <70) or green (>=70) bar */\r\n  percentCompleteBar: percentCompleteBarFormatter,\r\n\r\n  /** Takes a cell value number (between 0-100) and displays Bootstrap \"progress-bar\" a red (<30), silver (>30 & <70) or green (>=70) bar */\r\n  progressBar: progressBarFormatter,\r\n\r\n  /** Takes a cell value and translates it (i18n). Requires an instance of the Translate Service:: `params: { i18n: this.translate } */\r\n  translate: translateFormatter,\r\n\r\n  /** Takes a boolean value, cast it to upperCase string and finally translates it (i18n). */\r\n  translateBoolean: translateBooleanFormatter,\r\n\r\n  /** Takes a value and displays it all uppercase */\r\n  uppercase: uppercaseFormatter,\r\n\r\n  /** Takes a boolean value and display a string 'Yes' or 'No' */\r\n  yesNo: yesNoFormatter\r\n};\r\n",
    "import { Component, OnDestroy, Input, AfterViewInit, Injectable } from '@angular/core';\r\nimport { castToPromise } from './../services/utilities';\r\nimport { GridOption } from './../models/index';\r\nimport { FilterService, SortService } from './../services/index';\r\nimport { Subscription } from 'rxjs/Subscription';\r\n\r\n@Component({\r\n  selector: 'slick-pagination',\r\n  template: `<div class=\"slick-pagination\">\r\n    <div class=\"slick-pagination-nav\">\r\n        <nav aria-label=\"Page navigation\">\r\n        <ul class=\"pagination\">\r\n            <li class=\"page-item\" [ngClass]=\"pageNumber === 1 ? 'disabled' : ''\">\r\n            <a class=\"page-link icon-seek-first fa fa-angle-double-left\" aria-label=\"First\" (click)=\"changeToFirstPage($event)\">\r\n            </a>\r\n            </li>\r\n            <li class=\"page-item\" [ngClass]=\"pageNumber === 1 ? 'disabled' : ''\">\r\n            <a class=\"page-link icon-seek-prev fa fa-angle-left\" aria-label=\"Previous\" (click)=\"changeToPreviousPage($event)\">\r\n            </a>\r\n            </li>\r\n        </ul>\r\n        </nav>\r\n\r\n        <div class=\"slick-page-number\">\r\n            <span [translate]=\"'PAGE'\"></span>\r\n            <input type=\"text\" class=\"form-control\" value=\"{{pageNumber}}\" size=\"1\"  (change)=\"changeToCurrentPage($event)\">\r\n            <span [translate]=\"'OF'\"></span><span> {{pageCount}}</span>\r\n        </div>\r\n\r\n        <nav aria-label=\"Page navigation\">\r\n        <ul class=\"pagination\">\r\n            <li class=\"page-item\" [ngClass]=\"pageNumber === pageCount ? 'disabled' : ''\">\r\n            <a class=\"page-link icon-seek-next text-center fa fa-lg fa-angle-right\" aria-label=\"Next\" (click)=\"changeToNextPage($event)\">\r\n            </a>\r\n            </li>\r\n            <li class=\"page-item\" [ngClass]=\"pageNumber === pageCount ? 'disabled' : ''\">\r\n            <a class=\"page-link icon-seek-end fa fa-lg fa-angle-double-right\" aria-label=\"Last\" (click)=\"changeToLastPage($event)\">\r\n            </a>\r\n            </li>\r\n        </ul>\r\n        </nav>\r\n    </div>\r\n    <span class=\"slick-pagination-settings\">\r\n        <select id=\"items-per-page-label\" [value]=\"itemsPerPage\" (change)=\"onChangeItemPerPage($event)\">\r\n        <option value=\"{{pageSize}}\" *ngFor=\"let pageSize of paginationPageSizes;\">{{pageSize}}</option>\r\n        </select>\r\n        <span [translate]=\"'ITEMS_PER_PAGE'\"></span>,\r\n        <span class=\"slick-pagination-count\">\r\n            <span [translate]=\"'FROM_TO_OF_TOTAL_ITEMS'\" [translateParams]=\"{ from: dataFrom, to: dataTo, totalItems: totalItems }\"></span>\r\n        </span>\r\n    </span>\r\n    </div>\r\n`\r\n})\r\n@Injectable()\r\nexport class SlickPaginationComponent implements AfterViewInit, OnDestroy {\r\n  private _filterSubcription: Subscription;\r\n  private _sorterSubcription: Subscription;\r\n  private _gridPaginationOptions: GridOption;\r\n  private _isFirstRender = true;\r\n\r\n  @Input()\r\n  set gridPaginationOptions(gridPaginationOptions: GridOption) {\r\n    this._gridPaginationOptions = gridPaginationOptions;\r\n    if (this._isFirstRender || !gridPaginationOptions || !gridPaginationOptions.pagination || (gridPaginationOptions.pagination.totalItems !== this.totalItems)) {\r\n      this.refreshPagination();\r\n      this._isFirstRender = false;\r\n    }\r\n  }\r\n  get gridPaginationOptions(): GridOption {\r\n    return this._gridPaginationOptions;\r\n  }\r\n  @Input() grid: any;\r\n  dataFrom = 1;\r\n  dataTo = 1;\r\n  itemsPerPage: number;\r\n  pageCount = 0;\r\n  pageNumber = 1;\r\n  totalItems = 0;\r\n  paginationCallback: Function;\r\n  paginationPageSizes = [25, 75, 100];\r\n  fromToParams: any = { from: this.dataFrom, to: this.dataTo, totalItems: this.totalItems };\r\n\r\n  /** Constructor */\r\n  constructor(private filterService: FilterService, private sortService: SortService) { }\r\n\r\n  ngOnDestroy() {\r\n    this.dispose();\r\n  }\r\n\r\n  ngAfterViewInit() {\r\n    this._gridPaginationOptions = this._gridPaginationOptions;\r\n    if (!this._gridPaginationOptions || !this._gridPaginationOptions.pagination || (this._gridPaginationOptions.pagination.totalItems !== this.totalItems)) {\r\n      this.refreshPagination();\r\n    }\r\n\r\n    // Subscribe to Event Emitter of Filter & Sort changed, go back to page 1 when that happen\r\n    this._filterSubcription = this.filterService.onFilterChanged.subscribe((data) => {\r\n      this.refreshPagination(true);\r\n    });\r\n    this._sorterSubcription = this.sortService.onSortChanged.subscribe((data) => {\r\n      this.refreshPagination(true);\r\n    });\r\n  }\r\n\r\n  ceil(number: number) {\r\n    return Math.ceil(number);\r\n  }\r\n\r\n  changeToFirstPage(event: any) {\r\n    this.pageNumber = 1;\r\n    this.onPageChanged(event, this.pageNumber);\r\n  }\r\n\r\n  changeToLastPage(event: any) {\r\n    this.pageNumber = this.pageCount;\r\n    this.onPageChanged(event, this.pageNumber);\r\n  }\r\n\r\n  changeToNextPage(event: any) {\r\n    if (this.pageNumber < this.pageCount) {\r\n      this.pageNumber++;\r\n      this.onPageChanged(event, this.pageNumber);\r\n    }\r\n  }\r\n\r\n  changeToPreviousPage(event: any) {\r\n    if (this.pageNumber > 0) {\r\n      this.pageNumber--;\r\n      this.onPageChanged(event, this.pageNumber);\r\n    }\r\n  }\r\n\r\n  changeToCurrentPage(event: any) {\r\n    this.pageNumber = event.currentTarget.value;\r\n    if (this.pageNumber < 1) {\r\n          this.pageNumber = 1;\r\n    } else if (this.pageNumber > this.pageCount) {\r\n          this.pageNumber = this.pageCount;\r\n    }\r\n\r\n    this.onPageChanged(event, this.pageNumber);\r\n  }\r\n\r\n  dispose() {\r\n    if (this._filterSubcription) {\r\n      this._filterSubcription.unsubscribe();\r\n    }\r\n    if (this._sorterSubcription) {\r\n      this._sorterSubcription.unsubscribe();\r\n    }\r\n  }\r\n\r\n  onChangeItemPerPage(event: any) {\r\n    const itemsPerPage = +event.target.value;\r\n    this.pageCount = Math.ceil(this.totalItems / itemsPerPage);\r\n    this.pageNumber = 1;\r\n    this.itemsPerPage = itemsPerPage;\r\n    this.onPageChanged(event, this.pageNumber);\r\n  }\r\n\r\n  refreshPagination(isPageNumberReset: boolean = false) {\r\n    const backendApi = this._gridPaginationOptions.backendServiceApi || this._gridPaginationOptions.onBackendEventApi;\r\n    if (!backendApi || !backendApi.service || !backendApi.process) {\r\n      throw new Error(`BackendServiceApi requires at least a \"process\" function and a \"service\" defined`);\r\n    }\r\n\r\n    if (this._gridPaginationOptions && this._gridPaginationOptions.pagination) {\r\n      const pagination = this._gridPaginationOptions.pagination;\r\n      // set the number of items per page if not already set\r\n      if (!this.itemsPerPage) {\r\n        this.itemsPerPage = +((backendApi && backendApi.options && backendApi.options.paginationOptions && backendApi.options.paginationOptions.first) ? backendApi.options.paginationOptions.first : this._gridPaginationOptions.pagination.pageSize);\r\n      }\r\n\r\n      // if totalItems changed, we should always go back to the first page and recalculation the From-To indexes\r\n      if (isPageNumberReset || this.totalItems !== pagination.totalItems) {\r\n        if (this._isFirstRender && pagination.pageNumber && pagination.pageNumber > 1) {\r\n          this.pageNumber = pagination.pageNumber || 1;\r\n        } else {\r\n          this.pageNumber = 1;\r\n        }\r\n\r\n        // also reset the \"offset\" of backend service\r\n        backendApi.service.resetPaginationOptions();\r\n      }\r\n\r\n      // calculate and refresh the multiple properties of the pagination UI\r\n      this.paginationPageSizes = this._gridPaginationOptions.pagination.pageSizes;\r\n      this.totalItems = this._gridPaginationOptions.pagination.totalItems;\r\n      this.recalculateFromToIndexes();\r\n    }\r\n    this.pageCount = Math.ceil(this.totalItems / this.itemsPerPage);\r\n  }\r\n\r\n  async onPageChanged(event: Event | undefined, pageNumber: number) {\r\n    this.recalculateFromToIndexes();\r\n\r\n    const backendApi = this._gridPaginationOptions.backendServiceApi || this._gridPaginationOptions.onBackendEventApi;\r\n    if (!backendApi || !backendApi.service || !backendApi.process) {\r\n      throw new Error(`BackendServiceApi requires at least a \"process\" function and a \"service\" defined`);\r\n    }\r\n\r\n    if (this.dataTo > this.totalItems) {\r\n      this.dataTo = this.totalItems;\r\n    } else if (this.totalItems < this.itemsPerPage) {\r\n      this.dataTo = this.totalItems;\r\n    }\r\n    if (backendApi) {\r\n      const itemsPerPage = +this.itemsPerPage;\r\n\r\n      if (backendApi.preProcess) {\r\n        backendApi.preProcess();\r\n      }\r\n\r\n      const query = backendApi.service.onPaginationChanged(event, { newPage: pageNumber, pageSize: itemsPerPage });\r\n\r\n      // the process could be an Observable (like HttpClient) or a Promise\r\n      // in any case, we need to have a Promise so that we can await on it (if an Observable, convert it to Promise)\r\n      const observableOrPromise = backendApi.process(query);\r\n      const processResult = await castToPromise(observableOrPromise);\r\n\r\n      // from the result, call our internal post process to update the Dataset and Pagination info\r\n      if (processResult && backendApi.internalPostProcess) {\r\n        backendApi.internalPostProcess(processResult);\r\n      }\r\n\r\n      // send the response process to the postProcess callback\r\n      if (backendApi.postProcess) {\r\n        backendApi.postProcess(processResult);\r\n      }\r\n    } else {\r\n      throw new Error('Pagination with a backend service requires \"BackendServiceApi\" to be defined in your grid options');\r\n    }\r\n  }\r\n\r\n  recalculateFromToIndexes() {\r\n    this.dataFrom = (this.pageNumber * this.itemsPerPage) - this.itemsPerPage + 1;\r\n    this.dataTo = (this.totalItems < this.itemsPerPage) ? this.totalItems : (this.pageNumber * this.itemsPerPage);\r\n  }\r\n}\r\n",
    "import { DelimiterType, FileType,  GridOption } from './models/index';\r\n\r\n/**\r\n * Options that can be passed to the Bootstrap-Datetimepicker directly\r\n */\r\nexport const GlobalGridOptions: GridOption = {\r\n  autoEdit: false,\r\n  asyncEditorLoading: false,\r\n  autoFitColumnsOnFirstLoad: true,\r\n  autoResize: {\r\n    bottomPadding: 20,\r\n    minHeight: 180,\r\n    minWidth: 300,\r\n    sidePadding: 0\r\n  },\r\n  cellHighlightCssClass: 'slick-cell-modified',\r\n  checkboxSelector: {\r\n    cssClass: 'slick-cell-checkboxsel'\r\n  },\r\n  columnPicker: {\r\n    hideForceFitButton: false,\r\n    hideSyncResizeButton: true\r\n  },\r\n  datasetIdPropertyName: 'id',\r\n  editable: false,\r\n  enableAutoResize: true,\r\n  enableCellNavigation: false,\r\n  enableColumnPicker: true,\r\n  enableColumnReorder: true,\r\n  enableExport: true,\r\n  enableGridMenu: true,\r\n  enableMouseHoverHighlightRow: true,\r\n  enableSorting: true,\r\n  enableTextSelectionOnCells: true,\r\n  explicitInitialization: true,\r\n  exportWithFormatter: false,\r\n  forceFitColumns: false,\r\n  gridMenu: {\r\n    hideForceFitButton: false,\r\n    hideSyncResizeButton: true,\r\n    iconCssClass: 'fa fa-bars',\r\n    menuWidth: 16,\r\n    resizeOnShowHeaderRow: false,\r\n    showClearAllFiltersCommand: true,\r\n    showExportCsvCommand: true,\r\n    showRefreshDatasetCommand: true,\r\n    showToggleFilterCommand: true\r\n  },\r\n  headerRowHeight: 35,\r\n  multiColumnSort: true,\r\n  pagination: {\r\n    pageSizes: [10, 15, 20, 25, 30, 40, 50, 75, 100],\r\n    pageSize: 25,\r\n    totalItems: 0\r\n  },\r\n  rowHeight: 35,\r\n  showHeaderRow: false,\r\n  topPanelHeight: 35\r\n};\r\n",
    "import { GridOption, Column } from './../models/index';\r\n\r\nexport class SharedService {\r\n  dataView: any;\r\n  grid: any;\r\n  gridOptions: GridOption;\r\n  columnDefinitions: Column[];\r\n\r\n  init(grid: any, dataView: any, gridOptions: GridOption, columnDefinitions: Column[]) {\r\n    this.grid = grid;\r\n    this.dataView = dataView;\r\n    this.gridOptions = gridOptions;\r\n    this.columnDefinitions = columnDefinitions;\r\n  }\r\n}\r\n",
    "// import 3rd party vendor libs\r\nimport 'slickgrid/lib/jquery-ui-1.11.3';\r\nimport 'slickgrid/lib/jquery.event.drag-2.3.0';\r\nimport 'slickgrid/slick.core';\r\nimport 'slickgrid/slick.dataview';\r\nimport 'slickgrid/slick.grid';\r\nimport 'slickgrid/slick.dataview';\r\nimport 'slickgrid/controls/slick.columnpicker';\r\nimport 'slickgrid/controls/slick.gridmenu';\r\nimport 'slickgrid/controls/slick.pager';\r\nimport 'slickgrid/plugins/slick.autotooltips';\r\nimport 'slickgrid/plugins/slick.cellcopymanager';\r\nimport 'slickgrid/plugins/slick.cellexternalcopymanager';\r\nimport 'slickgrid/plugins/slick.cellrangedecorator';\r\nimport 'slickgrid/plugins/slick.cellrangeselector';\r\nimport 'slickgrid/plugins/slick.cellselectionmodel';\r\nimport 'slickgrid/plugins/slick.checkboxselectcolumn';\r\nimport 'slickgrid/plugins/slick.headerbuttons';\r\nimport 'slickgrid/plugins/slick.headermenu';\r\nimport 'slickgrid/plugins/slick.rowmovemanager';\r\nimport 'slickgrid/plugins/slick.rowselectionmodel';\r\nimport { AfterViewInit, Component, EventEmitter, Inject, Injectable, Input, Output, OnDestroy, OnInit } from '@angular/core';\r\nimport { TranslateService } from '@ngx-translate/core';\r\nimport { castToPromise } from './../services/utilities';\r\nimport { GlobalGridOptions } from './../global-grid-options';\r\nimport { BackendServiceOption, Column, GridOption } from './../models/index';\r\nimport { ControlAndPluginService } from './../services/controlAndPlugin.service';\r\nimport { ExportService } from './../services/export.service';\r\nimport { FilterService } from './../services/filter.service';\r\nimport { GraphqlService } from './../services/graphql.service';\r\nimport { GridEventService } from './../services/gridEvent.service';\r\nimport { GridExtraService } from './../services/gridExtra.service';\r\nimport { GridStateService } from './../services/gridState.service';\r\nimport { ResizerService } from './../services/resizer.service';\r\nimport { SharedService } from '../services/shared.service';\r\nimport { SortService } from './../services/sort.service';\r\nimport { Subscription } from 'rxjs/Subscription';\r\nimport $ from 'jquery';\r\n\r\n// using external non-typed js libraries\r\ndeclare var Slick: any;\r\ndeclare var $: any;\r\n\r\n@Injectable()\r\n@Component({\r\n  selector: 'angular-slickgrid',\r\n  template: `<div id=\"slickGridContainer-{{gridId}}\" class=\"gridPane\">\r\n    <div attr.id='{{gridId}}' class=\"slickgrid-container\" [style.height]=\"gridHeightString\" [style.width]=\"gridWidthString\">\r\n    </div>\r\n\r\n    <slick-pagination id=\"slickPagingContainer-{{gridId}}\" *ngIf=\"showPagination\" [gridPaginationOptions]=\"gridPaginationOptions\"></slick-pagination>\r\n</div>`\r\n})\r\nexport class AngularSlickgridComponent implements AfterViewInit, OnDestroy, OnInit {\r\n  private _dataset: any[];\r\n  private _dataView: any;\r\n  private _eventHandler: any = new Slick.EventHandler();\r\n  private _gridOptions: GridOption;\r\n  private _translateSubscription: Subscription;\r\n  grid: any;\r\n  gridPaginationOptions: GridOption;\r\n  gridHeightString: string;\r\n  gridWidthString: string;\r\n  groupingDefinition: any = {};\r\n  showPagination = false;\r\n\r\n  @Output() dataviewChanged = new EventEmitter<any>();\r\n  @Output() gridChanged = new EventEmitter<any>();\r\n  @Output() onDataviewCreated = new EventEmitter<any>();\r\n  @Output() onGridCreated = new EventEmitter<any>();\r\n  @Output() onGridInitialized = new EventEmitter<any>();\r\n  @Output() onBeforeGridCreate = new EventEmitter<boolean>();\r\n  @Output() onBeforeGridDestroy = new EventEmitter<any>();\r\n  @Output() onAfterGridDestroyed = new EventEmitter<boolean>();\r\n  @Input() gridId: string;\r\n  @Input() columnDefinitions: Column[];\r\n  @Input() gridOptions: GridOption;\r\n  @Input() gridHeight = 100;\r\n  @Input() gridWidth = 600;\r\n  @Input()\r\n  set dataset(dataset: any[]) {\r\n    this._dataset = dataset;\r\n    this.refreshGridData(dataset);\r\n  }\r\n  get dataset(): any[] {\r\n    return this._dataView.getItems();\r\n  }\r\n\r\n  constructor(\r\n    private controlAndPluginService: ControlAndPluginService,\r\n    private exportService: ExportService,\r\n    private filterService: FilterService,\r\n    private gridExtraService: GridExtraService,\r\n    private gridEventService: GridEventService,\r\n    private gridStateService: GridStateService,\r\n    private resizer: ResizerService,\r\n    private sharedService: SharedService,\r\n    private sortService: SortService,\r\n    private translate: TranslateService,\r\n    @Inject('config') private forRootConfig: GridOption\r\n  ) {}\r\n\r\n  ngOnInit(): void {\r\n    this.onBeforeGridCreate.emit(true);\r\n    this.gridHeightString = `${this.gridHeight}px`;\r\n    this.gridWidthString = `${this.gridWidth}px`;\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    this.onBeforeGridDestroy.emit(this.grid);\r\n    this.destroy();\r\n    this.onAfterGridDestroyed.emit(true);\r\n  }\r\n\r\n  destroy() {\r\n    this._dataView = [];\r\n    this._gridOptions = {};\r\n    this._eventHandler.unsubscribeAll();\r\n    this.controlAndPluginService.dispose();\r\n    this.gridEventService.dispose();\r\n    this.filterService.dispose();\r\n    this.resizer.dispose();\r\n    this.sortService.dispose();\r\n    this.grid.destroy();\r\n    if (this._translateSubscription) {\r\n      this._translateSubscription.unsubscribe();\r\n    }\r\n  }\r\n\r\n  ngAfterViewInit() {\r\n    // make sure the dataset is initialized (if not it will throw an error that it cannot getLength of null)\r\n    this._dataset = this._dataset || [];\r\n    this._gridOptions = this.mergeGridOptions();\r\n    this.createBackendApiInternalPostProcessCallback(this._gridOptions);\r\n\r\n    this._dataView = new Slick.Data.DataView();\r\n    this.controlAndPluginService.createPluginBeforeGridCreation(this.columnDefinitions, this._gridOptions);\r\n    this.grid = new Slick.Grid(`#${this.gridId}`, this._dataView, this.columnDefinitions, this._gridOptions);\r\n\r\n    this.controlAndPluginService.attachDifferentControlOrPlugins(this.grid, this.columnDefinitions, this._gridOptions, this._dataView);\r\n    this.attachDifferentHooks(this.grid, this._gridOptions, this._dataView);\r\n\r\n    // emit the Grid & DataView object to make them available in parent component\r\n    this.onGridCreated.emit(this.grid);\r\n    this.onDataviewCreated.emit(this._dataView);\r\n\r\n    // OBSOLETE in future releases, previous emitter functions (decided to rename them with onX prefix)\r\n    this.gridChanged.emit('DEPRECATED and replaced by \"onGridCreated\" Event Emitter.');\r\n    this.dataviewChanged.emit('DEPRECATED and replaced by \"onDataviewCreated\" Event Emitter.');\r\n\r\n    this.grid.init();\r\n    this._dataView.beginUpdate();\r\n    this._dataView.setItems(this._dataset, this._gridOptions.datasetIdPropertyName);\r\n    this._dataView.endUpdate();\r\n\r\n    // pass all necessary options to the shared service\r\n    this.sharedService.init(this.grid, this._dataView, this._gridOptions, this.columnDefinitions);\r\n\r\n    // attach resize ONLY after the dataView is ready\r\n    this.attachResizeHook(this.grid, this._gridOptions);\r\n\r\n    // attach grid extra service\r\n    this.gridExtraService.init(this.grid, this.columnDefinitions, this._gridOptions, this._dataView);\r\n\r\n    // when user enables translation, we need to translate Headers on first pass & subsequently in the attachDifferentHooks\r\n    if (this._gridOptions.enableTranslate) {\r\n      this.controlAndPluginService.translateHeaders();\r\n    }\r\n\r\n    // if Export is enabled, initialize the service with the necessary grid and other objects\r\n    if (this._gridOptions.enableExport) {\r\n      this.exportService.init(this.grid, this._gridOptions, this._dataView);\r\n    }\r\n\r\n    // once all hooks are in placed and the grid is initialized, we can emit an event\r\n    this.onGridInitialized.emit(this.grid);\r\n\r\n    // attach the Backend Service API callback functions only after the grid is initialized\r\n    // because the preProcess() and onInit() might get triggered\r\n    if (this._gridOptions && (this._gridOptions.backendServiceApi || this._gridOptions.onBackendEventApi)) {\r\n      this.attachBackendCallbackFunctions(this._gridOptions);\r\n    }\r\n\r\n    this.gridStateService.init(this.grid, this.filterService, this.sortService);\r\n  }\r\n\r\n  /**\r\n   * Define what our internal Post Process callback, it will execute internally after we get back result from the Process backend call\r\n   * For now, this is GraphQL Service only feautre and it will basically refresh the Dataset & Pagination without having the user to create his own PostProcess every time\r\n   */\r\n  createBackendApiInternalPostProcessCallback(gridOptions: GridOption) {\r\n    if (gridOptions && (gridOptions.backendServiceApi || gridOptions.onBackendEventApi)) {\r\n      const backendApi = gridOptions.backendServiceApi || gridOptions.onBackendEventApi;\r\n\r\n      // internalPostProcess only works with a GraphQL Service, so make sure it is that type\r\n      if (backendApi && backendApi.service && backendApi.service instanceof GraphqlService) {\r\n        backendApi.internalPostProcess = (processResult: any) => {\r\n          const datasetName = (backendApi && backendApi.service && typeof backendApi.service.getDatasetName === 'function') ? backendApi.service.getDatasetName() : '';\r\n          if (!processResult || !processResult.data || !processResult.data[datasetName]) {\r\n            throw new Error(`Your GraphQL result is invalid and/or does not follow the required result structure. Please check the result and/or review structure to use in Angular-Slickgrid Wiki in the GraphQL section.`);\r\n          }\r\n          this._dataset = processResult.data[datasetName].nodes;\r\n          this.refreshGridData(this._dataset, processResult.data[datasetName].totalCount);\r\n        };\r\n      }\r\n    }\r\n  }\r\n\r\n  attachDifferentHooks(grid: any, gridOptions: GridOption, dataView: any) {\r\n    // on locale change, we have to manually translate the Headers, GridMenu\r\n    this._translateSubscription = this.translate.onLangChange.subscribe((event) => {\r\n      if (gridOptions.enableTranslate) {\r\n        this.controlAndPluginService.translateHeaders();\r\n        this.controlAndPluginService.translateColumnPicker();\r\n        this.controlAndPluginService.translateGridMenu();\r\n      }\r\n    });\r\n\r\n    // attach external sorting (backend) when available or default onSort (dataView)\r\n    if (gridOptions.enableSorting) {\r\n      (gridOptions.backendServiceApi || gridOptions.onBackendEventApi) ? this.sortService.attachBackendOnSort(grid, gridOptions) : this.sortService.attachLocalOnSort(grid, gridOptions, this._dataView, this.columnDefinitions);\r\n    }\r\n\r\n    // attach external filter (backend) when available or default onFilter (dataView)\r\n    if (gridOptions.enableFiltering) {\r\n      this.filterService.init(grid, gridOptions, this.columnDefinitions);\r\n\r\n      // if user entered some \"presets\", we need to reflect them all in the DOM\r\n      if (gridOptions.presets && gridOptions.presets.filters) {\r\n        this.filterService.populateColumnFilterSearchTerms(gridOptions, this.columnDefinitions);\r\n      }\r\n      (gridOptions.backendServiceApi || gridOptions.onBackendEventApi) ? this.filterService.attachBackendOnFilter(grid, gridOptions) : this.filterService.attachLocalOnFilter(grid, gridOptions, this._dataView);\r\n    }\r\n\r\n    // if user set an onInit Backend, we'll run it right away (and if so, we also need to run preProcess, internalPostProcess & postProcess)\r\n    if (gridOptions.backendServiceApi || gridOptions.onBackendEventApi) {\r\n      const backendApi = gridOptions.backendServiceApi || gridOptions.onBackendEventApi;\r\n      if (gridOptions.onBackendEventApi) {\r\n        console.warn(`\"onBackendEventApi\" has been DEPRECATED, please consider using \"backendServiceApi\" in the short term since \"onBackendEventApi\" will be removed in future versions. You can take look at the Angular-Slickgrid Wikis for OData/GraphQL Services implementation`);\r\n      }\r\n\r\n      if (backendApi && backendApi.service && backendApi.service.init) {\r\n        backendApi.service.init(backendApi.options, gridOptions.pagination, this.grid);\r\n      }\r\n    }\r\n\r\n    // on cell click, mainly used with the columnDef.action callback\r\n    this.gridEventService.attachOnCellChange(grid, this._gridOptions, dataView);\r\n    this.gridEventService.attachOnClick(grid, this._gridOptions, dataView);\r\n\r\n    this._eventHandler.subscribe(dataView.onRowCountChanged, (e: any, args: any) => {\r\n      grid.updateRowCount();\r\n      grid.render();\r\n    });\r\n    this._eventHandler.subscribe(dataView.onRowsChanged, (e: any, args: any) => {\r\n      grid.invalidateRows(args.rows);\r\n      grid.render();\r\n    });\r\n  }\r\n\r\n  attachBackendCallbackFunctions(gridOptions: GridOption) {\r\n    const backendApi = gridOptions.backendServiceApi || gridOptions.onBackendEventApi;\r\n    const serviceOptions: BackendServiceOption = (backendApi && backendApi.service && backendApi.service.options) ? backendApi.service.options : {};\r\n    const isExecuteCommandOnInit = (!serviceOptions) ? false : ((serviceOptions && serviceOptions.hasOwnProperty('executeProcessCommandOnInit')) ? serviceOptions['executeProcessCommandOnInit'] : true);\r\n\r\n    // update backend filters (if need be) before the query runs\r\n    if (backendApi) {\r\n      const backendService = backendApi.service;\r\n      if (gridOptions && gridOptions.presets) {\r\n        if (backendService && backendService.updateFilters && gridOptions.presets.filters) {\r\n          backendService.updateFilters(gridOptions.presets.filters, true);\r\n        }\r\n        if (backendService && backendService.updateSorters && gridOptions.presets.sorters) {\r\n          backendService.updateSorters(undefined, gridOptions.presets.sorters);\r\n        }\r\n        if (backendService && backendService.updatePagination && gridOptions.presets.pagination) {\r\n          backendService.updatePagination(gridOptions.presets.pagination.pageNumber, gridOptions.presets.pagination.pageSize);\r\n        }\r\n      } else {\r\n        const columnFilters = this.filterService.getColumnFilters();\r\n        if (columnFilters && backendService && backendService.updateFilters) {\r\n          backendService.updateFilters(columnFilters, false);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (backendApi && backendApi.service && (backendApi.onInit || isExecuteCommandOnInit)) {\r\n      const query = (typeof backendApi.service.buildQuery === 'function') ? backendApi.service.buildQuery() : '';\r\n      const observableOrPromise = (isExecuteCommandOnInit) ? backendApi.process(query) : backendApi.onInit(query);\r\n\r\n      // wrap this inside a setTimeout to avoid timing issue since the gridOptions needs to be ready before running this onInit\r\n      setTimeout(async () => {\r\n        if (backendApi.preProcess) {\r\n          backendApi.preProcess();\r\n        }\r\n\r\n        // the process could be an Observable (like HttpClient) or a Promise\r\n        // in any case, we need to have a Promise so that we can await on it (if an Observable, convert it to Promise)\r\n        const processResult = await castToPromise(observableOrPromise);\r\n\r\n        // define what our internal Post Process callback, only available for GraphQL Service for now\r\n        // it will basically refresh the Dataset & Pagination without having the user to create his own PostProcess every time\r\n        if (processResult && backendApi && backendApi.service instanceof GraphqlService && backendApi.internalPostProcess) {\r\n          backendApi.internalPostProcess(processResult);\r\n        }\r\n\r\n        // send the response process to the postProcess callback\r\n        if (backendApi.postProcess) {\r\n          backendApi.postProcess(processResult);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  attachResizeHook(grid: any, options: GridOption) {\r\n    // expand/autofit columns on first page load\r\n    if (grid && options.autoFitColumnsOnFirstLoad) {\r\n      grid.autosizeColumns();\r\n    }\r\n\r\n    // auto-resize grid on browser resize\r\n    this.resizer.init(grid, options);\r\n    if (options.enableAutoResize) {\r\n      this.resizer.attachAutoResizeDataGrid();\r\n      if (grid && options.autoFitColumnsOnFirstLoad) {\r\n        grid.autosizeColumns();\r\n      }\r\n    } else {\r\n      this.resizer.resizeGrid(0, { height: this.gridHeight, width: this.gridWidth });\r\n    }\r\n  }\r\n\r\n  mergeGridOptions(): GridOption {\r\n    this.gridOptions.gridId = this.gridId;\r\n    this.gridOptions.gridContainerId = `slickGridContainer-${this.gridId}`;\r\n    if (this.gridOptions.enableFiltering || this.forRootConfig.enableFiltering) {\r\n      this.gridOptions.showHeaderRow = true;\r\n    }\r\n    // use jquery extend to deep merge and avoid immutable properties changed in GlobalGridOptions after route change\r\n    return $.extend(true, {}, GlobalGridOptions, this.forRootConfig, this.gridOptions);\r\n  }\r\n\r\n  /**\r\n   * When dataset changes, we need to refresh the entire grid UI & possibly resize it as well\r\n   * @param dataset\r\n   */\r\n  refreshGridData(dataset: any[], totalCount?: number) {\r\n    if (dataset && this.grid && this._dataView && typeof this._dataView.setItems === 'function') {\r\n      this._dataView.setItems(dataset, this._gridOptions.datasetIdPropertyName);\r\n\r\n      // this.grid.setData(dataset);\r\n      this.grid.invalidate();\r\n      this.grid.render();\r\n\r\n      if (this._gridOptions.enablePagination || this._gridOptions.backendServiceApi) {\r\n        // do we want to show pagination?\r\n        // if we have a backendServiceApi and the enablePagination is undefined, we'll assume that we do want to see it, else get that defined value\r\n        this.showPagination = ((this._gridOptions.backendServiceApi && this._gridOptions.enablePagination === undefined) ? true : this._gridOptions.enablePagination) || false;\r\n\r\n        // before merging the grid options, make sure that it has the totalItems count\r\n        // once we have that, we can merge and pass all these options to the pagination component\r\n        if (!this.gridOptions.pagination) {\r\n          this.gridOptions.pagination = (this._gridOptions.pagination) ? this._gridOptions.pagination : undefined;\r\n        }\r\n        if (this.gridOptions.pagination && totalCount) {\r\n          this.gridOptions.pagination.totalItems = totalCount;\r\n        }\r\n        if (this.gridOptions.presets && this.gridOptions.presets.pagination && this.gridOptions.pagination) {\r\n          this.gridOptions.pagination.pageSize = this.gridOptions.presets.pagination.pageSize;\r\n          this.gridOptions.pagination.pageNumber = this.gridOptions.presets.pagination.pageNumber;\r\n        }\r\n        this.gridPaginationOptions = this.mergeGridOptions();\r\n      }\r\n      if (this.grid &&  this._gridOptions.enableAutoResize) {\r\n        // resize the grid inside a slight timeout, in case other DOM element changed prior to the resize (like a filter/pagination changed)\r\n        this.resizer.resizeGrid(10);\r\n        // this.grid.autosizeColumns();\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Toggle the filter row displayed on first row\r\n   * @param isShowing\r\n   */\r\n  showHeaderRow(isShowing: boolean) {\r\n    this.grid.setHeaderRowVisibility(isShowing);\r\n    return isShowing;\r\n  }\r\n\r\n  /** Toggle the filter row displayed on first row */\r\n  toggleHeaderRow() {\r\n    const isShowing = !this.grid.getOptions().showHeaderRow;\r\n    this.grid.setHeaderRowVisibility(isShowing);\r\n    return isShowing;\r\n  }\r\n}\r\n",
    "import { SharedService } from './../services/shared.service';\r\nimport { CommonModule } from '@angular/common';\r\nimport { NgModule } from '@angular/core';\r\nimport { TranslateModule } from '@ngx-translate/core';\r\nimport { AngularSlickgridComponent } from './../components/angular-slickgrid.component';\r\nimport { ControlAndPluginService } from '../services/controlAndPlugin.service';\r\nimport { ExportService } from '../services/export.service';\r\nimport { FilterService } from './../services/filter.service';\r\nimport { GridOdataService } from './../services/grid-odata.service';\r\nimport { GridOption } from './../models/gridOption.interface';\r\nimport { GridEventService } from './../services/gridEvent.service';\r\nimport { GridExtraService } from './../services/gridExtra.service';\r\nimport { GridStateService } from './../services/gridState.service';\r\nimport { GraphqlService } from './../services/graphql.service';\r\nimport { OdataService } from './../services/odata.service';\r\nimport { ResizerService } from './../services/resizer.service';\r\nimport { SlickPaginationComponent } from './../components/slick-pagination.component';\r\nimport { SortService } from './../services/sort.service';\r\n\r\n@NgModule({\r\n  imports: [\r\n    CommonModule,\r\n    TranslateModule\r\n  ],\r\n  declarations: [\r\n    AngularSlickgridComponent,\r\n    SlickPaginationComponent\r\n  ],\r\n  exports: [\r\n    AngularSlickgridComponent,\r\n    SlickPaginationComponent\r\n  ]\r\n})\r\nexport class AngularSlickgridModule {\r\n  static forRoot(config: GridOption = {}) {\r\n    return {\r\n      ngModule: AngularSlickgridModule,\r\n      providers: [\r\n        {provide: 'config', useValue: config},\r\n        ControlAndPluginService,\r\n        ExportService,\r\n        FilterService,\r\n        GraphqlService,\r\n        GridEventService,\r\n        GridExtraService,\r\n        GridOdataService,\r\n        GridStateService,\r\n        OdataService,\r\n        ResizerService,\r\n        SharedService,\r\n        SortService\r\n      ]\r\n    };\r\n  }\r\n}\r\n"
  ],
  "names": [
    "__awaiter",
    "thisArg",
    "_arguments",
    "P",
    "generator",
    "Promise",
    "resolve",
    "reject",
    "fulfilled",
    "value",
    "step",
    "next",
    "e",
    "rejected",
    "result",
    "done",
    "then",
    "apply",
    "__generator",
    "body",
    "verb",
    "n",
    "v",
    "op",
    "f",
    "TypeError",
    "_",
    "y",
    "t",
    "call",
    "label",
    "ops",
    "pop",
    "trys",
    "length",
    "push",
    "g",
    "sent",
    "throw",
    "return",
    "Symbol",
    "iterator",
    "this",
    "__values",
    "o",
    "m",
    "i",
    "htmlEntityDecode",
    "input",
    "replace",
    "match",
    "dec",
    "String",
    "fromCharCode",
    "castToPromise",
    "fromServiceName",
    "promise",
    "take",
    "toPromise",
    "map",
    "fieldType",
    "FieldType",
    "dateTime",
    "dateTimeIso",
    "dateUs",
    "dateUsShort",
    "dateTimeUs",
    "dateTimeUsAmPm",
    "dateTimeUsAM_PM",
    "dateTimeUsShort",
    "dateTimeUsShortAmPm",
    "dateUtc",
    "date",
    "dateIso",
    "mapFlatpickrDateFormatWithFieldType",
    "mapOperatorType",
    "operator",
    "OperatorType",
    "lessThan",
    "greaterThanOrEqual",
    "notEqual",
    "startsWith",
    "endsWith",
    "equal",
    "in",
    "notIn",
    "contains",
    "mapOperatorByFilterType",
    "filterType",
    "FilterType",
    "multipleSelect",
    "parseUtcDate",
    "inputDateString",
    "useUtc",
    "test",
    "dateString",
    "decodeURIComponent",
    "dateMoment",
    "moment",
    "Date",
    "toCamelCase",
    "str",
    "offset",
    "toLowerCase",
    "toUpperCase",
    "parseBoolean",
    "comma",
    "equalSign",
    "pipe",
    "semicolon",
    "space",
    "tab",
    "doubleColon",
    "doublePipe",
    "doubleSemicolon",
    "pdf",
    "txt",
    "xls",
    "xlsx",
    "SortDirection",
    "ExportService",
    "translate",
    "delimiter",
    "DelimiterType",
    "prototype",
    "init",
    "grid",
    "gridOptions",
    "dataView",
    "_grid",
    "_gridOptions",
    "_dataView",
    "exportToFile",
    "options",
    "_exportOptions",
    "$",
    "extend",
    "defaultExportOptions",
    "getDataOutput",
    "columns",
    "getColumns",
    "format",
    "_existingSlickAggregators",
    "getAllSlickGridAggregators",
    "_exportQuoteWrapper",
    "FileType",
    "csv",
    "outputDataString",
    "_hasGroupedItems",
    "_groupedHeaders",
    "header",
    "_this",
    "instant",
    "title",
    "join",
    "_columnHeaders",
    "Array",
    "isArray",
    "_lineCarriageReturn",
    "getAllGridRowData",
    "lineCarriageReturn",
    "lineCount",
    "getLength",
    "rowNumber",
    "itemObj",
    "getItem",
    "readGroupedTitleRow",
    "readGroupedTotalRow",
    "key",
    "Slick",
    "Data",
    "Aggregators",
    "hasOwnProperty",
    "existingSlickAggregators",
    "getColumnHeaders",
    "columnHeaders",
    "forEach",
    "columnDef",
    "field",
    "id",
    "fieldName",
    "readRegularRowData",
    "row",
    "idx",
    "rowOutputString",
    "isEvaluatingFormatter",
    "exportWithFormatter",
    "undefined",
    "exportCustomFormatter",
    "itemData",
    "col",
    "fieldId",
    "formatter",
    "toString",
    "exportCsvForceToKeepAsString",
    "exportQuoteWrapper",
    "groupName",
    "addWhiteSpaces",
    "level",
    "k",
    "aggregatorName",
    "val",
    "Math",
    "round",
    "parseFloat",
    "output",
    "getGroupedColumnTitles",
    "groupItemId",
    "hasGroupedItems",
    "_groupingDefinition",
    "dropdownOptionsIds",
    "indexOf",
    "split",
    "headerKey",
    "name",
    "groupedHeaders",
    "startDownloadFile",
    "navigator",
    "appName",
    "Error",
    "outputData",
    "TextEncoder",
    "encode",
    "csvContent",
    "msSaveOrOpenBlob",
    "blob",
    "filename",
    "csvUrl",
    "URL",
    "createObjectURL",
    "link",
    "textContent",
    "href",
    "style",
    "visibility",
    "document",
    "appendChild",
    "decorators",
    "ctorParameters",
    "type",
    "TranslateService",
    "value1",
    "value2",
    "includes",
    "moment$1",
    "moment_",
    "dateFilterCondition",
    "searchDateFormat",
    "mapMomentDateFormatWithFieldType",
    "filterSearchType",
    "cellValue",
    "ISO_8601",
    "isValid",
    "searchTerm",
    "dateCell",
    "moment$2",
    "FORMAT",
    "dateIsoFilterCondition",
    "dateSearch",
    "moment$3",
    "FORMAT$1",
    "dateUsFilterCondition",
    "testFilterCondition",
    "parseInt",
    "moment$4",
    "FORMAT$2",
    "dateUsShortFilterCondition",
    "dateUtcFilterCondition",
    "moment$5",
    "collectionSearchFilterCondition",
    "searchTerms",
    "numberFilterCondition",
    "stringFilterCondition",
    "boolean",
    "booleanFilterCondition",
    "number",
    "string",
    "FilterConditions",
    "executeMappedCondition",
    "booleanFilter",
    "collectionSearchFilter",
    "dateFilter",
    "dateIsoFilter",
    "dateUtcFilter",
    "dateUsFilter",
    "dateUsShortFilter",
    "numberFilter",
    "stringFilter",
    "testFilter",
    "InputFilter",
    "args",
    "callback",
    "filterTemplate",
    "buildTemplateHtmlString",
    "$filterElm",
    "createDomElement",
    "clear",
    "triggerFilterKeyup",
    "destroy",
    "off",
    "remove",
    "setValues",
    "values",
    "attr",
    "MultipleSelectFilter",
    "defaultOptions",
    "container",
    "filter",
    "maxHeight",
    "selectAllText",
    "onClose",
    "selectedItems",
    "addClass",
    "siblings",
    "removeClass",
    "triggerFilterChange",
    "collection",
    "optionCollection",
    "option",
    "labelName",
    "labelKey",
    "selected",
    "isFilled",
    "$headerElm",
    "getHeaderRowColumn",
    "data",
    "Object",
    "assign",
    "filterOptions",
    "findValueInSearchTerms",
    "SelectFilter",
    "selectOptions",
    "customStructure",
    "valueName",
    "textLabel",
    "enableTranslateLabel",
    "empty",
    "SingleSelectFilter",
    "appendTo",
    "Filters",
    "select",
    "FilterService",
    "_eventHandler",
    "EventHandler",
    "columnDefinitions",
    "_filters",
    "emitFilterChangedBy",
    "_subscriber",
    "Event",
    "subscribe",
    "attachBackendOnFilterSubscribe",
    "event",
    "backendApi",
    "query",
    "observableOrPromise",
    "processResult",
    "tslib_1.__generator",
    "_a",
    "process",
    "service",
    "preProcess",
    "onFilterChanged",
    "internalPostProcess",
    "postProcess",
    "columnId",
    "_columnFilters",
    "refresh",
    "render",
    "setFilterArgs",
    "columnFilters",
    "setFilter",
    "customLocalFilter",
    "bind",
    "onHeaderRowCellRendered",
    "tslib_1.__values",
    "keys",
    "_b",
    "columnFilter",
    "columnIndex",
    "getColumnIndex",
    "item",
    "queryField",
    "fieldSearchValue",
    "matches",
    "lastValueChar",
    "custom",
    "singleSelect",
    "ln",
    "params",
    "useFormatterOuputToFilter",
    "rowIndex",
    "getIdxById",
    "cellValueLastChar",
    "e_1_1",
    "e_1",
    "error",
    "disposeColumnFilters",
    "index",
    "getColumnFilters",
    "getCurrentLocalFilters",
    "currentFilters",
    "colId",
    "e_2_1",
    "e_2",
    "_c",
    "callbackSearchEvent",
    "targetValue",
    "target",
    "triggerEvent",
    "addFilterTemplateToHeaderRow",
    "column",
    "filterable",
    "updateColumnFilters",
    "filter_1",
    "filterArguments",
    "customFilter",
    "filterExistIndex",
    "sender",
    "emit",
    "presetFilter",
    "columnPreset",
    "evt",
    "notify",
    "ControlAndPluginService",
    "exportService",
    "filterService",
    "attachDifferentControlOrPlugins",
    "_columnDefinitions",
    "visibleColumns",
    "enableColumnPicker",
    "columnPickerControl",
    "createColumnPicker",
    "enableGridMenu",
    "gridMenuControl",
    "createGridMenu",
    "enableAutoTooltip",
    "autoTooltipPlugin",
    "AutoTooltips",
    "autoTooltipOptions",
    "registerPlugin",
    "enableCheckboxSelector",
    "checkboxSelectorPlugin",
    "rowSelectionPlugin",
    "RowSelectionModel",
    "rowSelectionOptions",
    "setSelectionModel",
    "enableRowSelection",
    "enableHeaderButton",
    "headerButtonsPlugin",
    "Plugins",
    "HeaderButtons",
    "headerButton",
    "onCommand",
    "enableHeaderMenu",
    "headerMenuOptions",
    "headerMenu",
    "minWidth",
    "autoAlignOffset",
    "headerMenuPlugin",
    "HeaderMenu",
    "onBeforeMenuShow",
    "registerPlugins",
    "plugin",
    "forceFitTitle",
    "enableTranslate",
    "syncResizeTitle",
    "columnPicker",
    "Controls",
    "ColumnPicker",
    "onColumnsChanged",
    "gridMenu",
    "getDefaultGridMenuOptions",
    "addGridMenuCustomCommands",
    "onMenuClose",
    "autosizeColumns",
    "hideColumn",
    "removeColumnByIndex",
    "array",
    "el",
    "autoResizeColumns",
    "dispose",
    "enableFiltering",
    "showClearAllFiltersCommand",
    "customItems",
    "command",
    "iconCssClass",
    "disabled",
    "positionOrder",
    "showToggleFilterCommand",
    "showRefreshDatasetCommand",
    "enableExport",
    "showExportCsvCommand",
    "showExportTextDelimitedCommand",
    "clearFilters",
    "useUtf8WithBom",
    "setHeaderRowVisibility",
    "getOptions",
    "showHeaderRow",
    "setTopPanelVisibility",
    "showTopPanel",
    "alert",
    "customTitle",
    "sort",
    "itemA",
    "itemB",
    "columnTitle",
    "menuWidth",
    "refreshBackendDataset",
    "backendServiceApi",
    "onBackendEventApi",
    "resetGridMenuTranslations",
    "translateColumnPicker",
    "translateGridMenu",
    "translateHeaders",
    "locale",
    "use",
    "e_3_1",
    "e_3",
    "selectionColumn",
    "excludeFromExport",
    "excludeFromQuery",
    "unshift",
    "Injectable",
    "timer",
    "GraphqlQueryBuilder",
    "queryFnName",
    "aliasOrFilter",
    "arguments",
    "filters",
    "prop",
    "head",
    "e_4",
    "find",
    "searches",
    "_i",
    "searchKeys",
    "parceFind",
    "setAlias",
    "alias",
    "ReferenceError",
    "itemX",
    "RangeError",
    "propsAA",
    "JSON",
    "stringify",
    "propS",
    "getGraphQLValue",
    "objectToString",
    "obj",
    "sourceA",
    "e_5_1",
    "e_5",
    "GraphqlService",
    "defaultPaginationOptions",
    "first",
    "DEFAULT_ITEMS_PER_PAGE",
    "columnIds",
    "pageInfoQb",
    "dataQb",
    "datasetQb",
    "datasetFilters",
    "paginationOptions",
    "pagination",
    "pageSize",
    "orderBy",
    "sortingOptions",
    "addLocaleIntoQuery",
    "currentLang",
    "trimDoubleQuotesOnEnumField",
    "queryQb",
    "keepArgumentFieldDoubleQuotes",
    "buildFilterQuery",
    "inputArray",
    "set",
    "a",
    "reduce",
    "serviceOptions",
    "getDatasetName",
    "getCurrentFilters",
    "_currentFilters",
    "getCurrentPagination",
    "_currentPagination",
    "getCurrentSorters",
    "resetPaginationOptions",
    "isWithCursor",
    "after",
    "getInitPaginationOptions",
    "debounceTypingDelay",
    "filterTypingDebounce",
    "updateFilters",
    "clearTimeout",
    "setTimeout",
    "buildQuery",
    "onPaginationChanged",
    "updatePagination",
    "newPage",
    "onSortChanged",
    "updateSorters",
    "sortColumns",
    "isUpdatedByPreset",
    "this_1",
    "columnFilter_1",
    "searchValue",
    "searchByArray",
    "_loop_1",
    "updateOptions",
    "filteringOptions",
    "pageNumber",
    "presetSorters",
    "currentSorters",
    "sorter",
    "direction",
    "tmpSorterArray",
    "sortAsc",
    "ASC",
    "defaultOrderBy",
    "sortColumns_1",
    "sortColumns_1_1",
    "sortCol",
    "DESC",
    "graphqlSorters",
    "_currentSorters",
    "e_6",
    "inputStr",
    "enumSearchWords",
    "patternRegex",
    "patternWordInQuotes",
    "removeDoubleQuotes",
    "group1",
    "castFilterToColumnFilter",
    "tmpFilter",
    "padZero",
    "s",
    "trim",
    "outputStr",
    "charAt",
    "substr",
    "_odataOptions",
    "filterQueue",
    "queryTmpArray",
    "top",
    "skip",
    "argument",
    "filterStr",
    "filterBySeparator",
    "filterBy",
    "saveColumnFilter",
    "updateFilterFromListTerms",
    "OdataService",
    "getFilterByColumn",
    "columnName",
    "getFilterCount",
    "get",
    "enumerable",
    "configurable",
    "removeColumnFilter",
    "search",
    "filterOptionObject",
    "updateFilterFromTerm",
    "fieldSearchTerms",
    "searchBy",
    "tmpSearchTerms",
    "lnk",
    "tmpSearchByArray",
    "property",
    "caseType",
    "CaseType",
    "pascalCase",
    "sortBy",
    "titleCase",
    "e_7_1",
    "e_7",
    "DEFAULT_ITEMS_PER_PAGE$1",
    "GridOdataService",
    "odataService",
    "mergedOptions",
    "terms",
    "timer$1",
    "_loop_2",
    "columnFilter_2",
    "this_2",
    "bypassOdataQuery",
    "bypassBackendQuery",
    "j",
    "dateFormatted",
    "mapOdataOperator",
    "sortByArray",
    "sorterArray",
    "e_8_1",
    "e_8",
    "sortColumns_2_1",
    "sortColumns_2",
    "timer$2",
    "GridEventService",
    "attachOnCellChange",
    "onCellChange",
    "cell",
    "getDataItem",
    "gridDefinition",
    "dataContext",
    "returnedArgs",
    "onClick",
    "onCellClick",
    "autoEdit",
    "GridExtraService",
    "columnDefinition",
    "getItemRowMetadata",
    "previousItemMetadata",
    "cssClasses",
    "isEmptyObject",
    "meta",
    "_dirty",
    "highlightRow",
    "fadeDelay",
    "getItemMetadata",
    "rowClass",
    "getSelectedRows",
    "setSelectedRows",
    "rowIndexes",
    "addItemToDatagrid",
    "scrollRowIntoView",
    "updateDataGridItem",
    "getRowById",
    "itemId",
    "updateItem",
    "GridExtraUtils",
    "getColumnDefinitionAndData",
    "GridStateService",
    "sortService",
    "getCurrentGridState",
    "gridState",
    "sorters",
    "currentPagination",
    "backendService",
    "ResizerService",
    "attachAutoResizeDataGrid",
    "gridDomElm",
    "gridId",
    "resizeGrid",
    "calculateGridNewDimensions",
    "bottomPadding",
    "autoResize",
    "enablePagination",
    "gridHeight",
    "windowElm",
    "coordOffsetTop",
    "availableHeight",
    "newHeight",
    "minHeight",
    "newWidth",
    "window",
    "delay",
    "newSizes",
    "gridElm",
    "gridContainerElm",
    "gridContainerId",
    "height",
    "width",
    "resizeCanvas",
    "moment$6",
    "FORMAT$3",
    "dateUsShortSorter",
    "sortDirection",
    "moment$7",
    "dateSorter",
    "date1",
    "date2",
    "diff",
    "moment$8",
    "FORMAT$4",
    "dateIsoSorter",
    "dateUsSorter",
    "moment$9",
    "FORMAT$5",
    "numericSorter",
    "x",
    "isNaN",
    "position",
    "Sorters",
    "numeric",
    "stringSorter",
    "SortService",
    "_currentLocalSorters",
    "EventEmitter",
    "attachBackendOnSortSubscribe",
    "attachLocalOnSort",
    "onSort",
    "sortColumn",
    "getCurrentLocalSorters",
    "sortCols",
    "presets",
    "currentSorter",
    "columnSortObj",
    "dataRow2",
    "sortField",
    "unsubscribe",
    "emitSortChangedBy",
    "CheckboxEditor",
    "$input",
    "focus",
    "hide",
    "show",
    "defaultValue",
    "preClick",
    "serializeValue",
    "validate",
    "require",
    "DateEditor",
    "outputFormat",
    "outputType",
    "currentLocale",
    "getCurrentLocale",
    "altFormat",
    "inputFormat",
    "dateFormat",
    "closeOnSelect",
    "loadFlatpickrLocale",
    "defaultDate",
    "flatInstance",
    "flatpickr",
    "pickerOptions",
    "i18n",
    "localeDefault",
    "open",
    "loadValue",
    "applyValue",
    "state",
    "isValueChanged",
    "validator",
    "validationResults",
    "valid",
    "FloatEditor",
    "on",
    "keyCode",
    "KeyCode",
    "LEFT",
    "RIGHT",
    "stopImmediatePropagation",
    "getDecimalPlaces",
    "decPlaces",
    "rtn",
    "toFixed",
    "msg",
    "IntegerEditor",
    "LongTextEditor",
    "$wrapper",
    "handleKeyDown",
    "which",
    "ENTER",
    "ctrlKey",
    "save",
    "ESCAPE",
    "preventDefault",
    "cancel",
    "TAB",
    "shiftKey",
    "navigatePrev",
    "navigateNext",
    "commitChanges",
    "cancelChanges",
    "css",
    "left",
    "TextEditor",
    "Editors",
    "text",
    "arrayToCsvFormatter",
    "checkmarkFormatter",
    "complexObjectFormatter",
    "moment$10",
    "FORMAT$6",
    "dateIsoFormatter",
    "moment$11",
    "FORMAT$7",
    "dateTimeIsoAmPm",
    "dateTimeIsoAmPmFormatter",
    "moment$13",
    "FORMAT$9",
    "dateTimeUsFormatter",
    "moment$14",
    "FORMAT$10",
    "dateUsFormatter",
    "matchUrl",
    "infoIconFormatter",
    "multipleFormatter",
    "formatters",
    "formatters_1",
    "formatters_1_1",
    "formattedValue",
    "e_9",
    "percentCompleteBarFormatter",
    "progressBarFormatter",
    "translateFormatter",
    "columnParams",
    "gridParams",
    "translateBooleanFormatter",
    "arrayToCsv",
    "checkbox",
    "checkboxFormatter",
    "checkmark",
    "dateTimeUsAmPmFormatter",
    "deleteIcon",
    "deleteIconFormatter",
    "infoIcon",
    "lowercase",
    "lowercaseFormatter",
    "multiple",
    "percentComplete",
    "percentCompleteFormatter",
    "percentCompleteBar",
    "translateBoolean",
    "uppercase",
    "uppercaseFormatter",
    "yesNo",
    "yesNoFormatter",
    "SlickPaginationComponent",
    "_isFirstRender",
    "totalItems",
    "paginationPageSizes",
    "fromToParams",
    "from",
    "dataFrom",
    "to",
    "dataTo",
    "defineProperty",
    "gridPaginationOptions",
    "_gridPaginationOptions",
    "ngOnDestroy",
    "ngAfterViewInit",
    "refreshPagination",
    "changeToFirstPage",
    "onPageChanged",
    "changeToLastPage",
    "pageCount",
    "changeToPreviousPage",
    "currentTarget",
    "recalculateFromToIndexes",
    "itemsPerPage",
    "Component",
    "selector",
    "template",
    "GlobalGridOptions",
    "enableAutoResize",
    "enableCellNavigation",
    "enableColumnReorder",
    "enableMouseHoverHighlightRow",
    "enableSorting",
    "enableTextSelectionOnCells",
    "explicitInitialization",
    "forceFitColumns",
    "hideForceFitButton",
    "hideSyncResizeButton",
    "resizeOnShowHeaderRow",
    "headerRowHeight",
    "multiColumnSort",
    "rowHeight",
    "topPanelHeight",
    "SharedService",
    "AngularSlickgridComponent",
    "gridExtraService",
    "gridEventService",
    "gridStateService",
    "resizer",
    "sharedService",
    "forRootConfig",
    "groupingDefinition",
    "showPagination",
    "gridChanged",
    "onDataviewCreated",
    "onGridCreated",
    "onGridInitialized",
    "onBeforeGridCreate",
    "onBeforeGridDestroy",
    "getItems",
    "dataset",
    "onAfterGridDestroyed",
    "unsubscribeAll",
    "_translateSubscription",
    "mergeGridOptions",
    "createBackendApiInternalPostProcessCallback",
    "DataView",
    "Grid",
    "controlAndPluginService",
    "beginUpdate",
    "setItems",
    "_dataset",
    "datasetIdPropertyName",
    "endUpdate",
    "attachResizeHook",
    "backendApi_1",
    "datasetName",
    "nodes",
    "refreshGridData",
    "totalCount",
    "attachDifferentHooks",
    "attachBackendOnSort",
    "attachOnClick",
    "onRowCountChanged",
    "updateRowCount",
    "attachBackendCallbackFunctions",
    "onInit",
    "isExecuteCommandOnInit",
    "observableOrPromise_1",
    "gridWidth",
    "isShowing",
    "toggleHeaderRow",
    "buf",
    "charCodeAt"
  ],
  "mappings": "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"
}
